/// <reference types="node" resolution-mode="require"/>
import * as types from "../generated/attestation-program/index.js";
import type { SwitchboardProgram } from "../SwitchboardProgram.js";
import type { SendTransactionObjectOptions, TransactionObjectOptions } from "../TransactionObject.js";
import { TransactionObject } from "../TransactionObject.js";
import { Account } from "./account.js";
import { AttestationPermissionAccount, AttestationQueueAccount } from "./index.js";
import type { TransactionInstruction, TransactionSignature } from "@solana/web3.js";
import { Keypair, PublicKey } from "@solana/web3.js";
import type { BN } from "@switchboard-xyz/common";
import { type RawBuffer } from "@switchboard-xyz/common";
export declare const QUOTE_SEED: string;
/**
 *  Parameters for initializing an {@linkcode VerifierAccount}
 */
export interface VerifierAccountInitParams {
    /**
     * Key to lookup the buffer data on IPFS or an alternative decentralized storage solution.
     */
    registryKey: Uint8Array;
    /**
     *  The queue to which this function account will be linked
     */
    queueAccount: AttestationQueueAccount;
    /**
     *  A keypair to be used to address this account
     *
     *  @default Keypair.generate()
     */
    keypair?: Keypair;
    /**
     *  An authority to be used to control this account.
     *
     *  @default payer
     */
    authority?: PublicKey;
}
/**
 *  Parameters for an {@linkcode types.quoteHeartbeat} instruction.
 */
export interface VerifierHeartbeatSyncParams {
    gcOracle: PublicKey;
    attestationQueue: PublicKey;
    permission: AttestationPermissionAccount;
    queueAuthority: PublicKey;
}
/**
 *  Parameters for an {@linkcode types.quoteHeartbeat} instruction.
 */
export type VerifierHeartbeatParams = Partial<VerifierHeartbeatSyncParams> & {
    enclaveSigner: Keypair;
} & Partial<{
    quote: types.VerifierAccountData;
    queue: types.AttestationQueueAccountData;
}>;
/**
 *  Parameters for an {@linkcode types.quoteVerify} instruction.
 */
export interface QuoteVerifyParams {
    /**
     *  @TODO: Docs for timestamp
     */
    timestamp: BN;
    /**
     *  @TODO: Docs for mrEnclave
     */
    mrEnclave: RawBuffer;
    /**
     * Keypair of the enclave signer generated in the verifiers secure enclave
     */
    enclaveSigner?: Keypair;
    quote: VerifierAccount;
    quoteState?: types.VerifierAccountData;
}
/**
 *  Parameters for an {@linkcode types.quoteRotate} instruction.
 */
export interface VerifierRotateParams {
    authority?: Keypair;
    enclaveSigner: Keypair;
    registryKey: string | Buffer | Uint8Array;
}
/**
 * Account type representing a Switchboard Attestation quote.
 *
 * Data: {@linkcode types.VerifierAccountData}
 */
export declare class VerifierAccount extends Account<types.VerifierAccountData> {
    static accountName: string;
    /**
     *  Load an existing {@linkcode VerifierAccount} with its current on-chain state
     */
    static load(program: SwitchboardProgram, address: PublicKey | string): Promise<[VerifierAccount, types.VerifierAccountData]>;
    /**
     * Finds the {@linkcode VerifierAccount} from the seed from which it was generated.
     *
     * Only applicable for VerifierAccounts tied to a {@linkcode FunctionAccount}. Enclaves can also be generated from a keypair.
     *
     * @return VerifierAccount and PDA bump tuple.
     */
    static fromSeed(program: SwitchboardProgram, functionPubkey: PublicKey): VerifierAccount;
    /**
     * Create a transaction object to initialize a quote account.
     */
    static createInstruction(program: SwitchboardProgram, payer: PublicKey, params: VerifierAccountInitParams, options?: TransactionObjectOptions): Promise<[VerifierAccount, TransactionObject]>;
    static create(program: SwitchboardProgram, params: VerifierAccountInitParams, options?: SendTransactionObjectOptions): Promise<[VerifierAccount, TransactionSignature]>;
    getPermissionAccount(queuePubkey: PublicKey, queueAuthority: PublicKey, owner: PublicKey): AttestationPermissionAccount;
    static getVerificationStatus(state: types.VerifierAccountData): types.VerificationStatusKind;
    /**
     *  Retrieve and decode the {@linkcode types.VerifierAccountData} stored in this account.
     */
    loadData(): Promise<types.VerifierAccountData>;
    heartbeatInstruction(params: {
        gcOracle: PublicKey;
        attestationQueue: PublicKey;
        permission: AttestationPermissionAccount;
        queueAuthority: PublicKey;
        enclaveSigner: PublicKey;
    }): TransactionInstruction;
    heartbeat(params: VerifierHeartbeatParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    rotateInstruction(payer: PublicKey, params: VerifierRotateParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    rotate(params: VerifierRotateParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    verifyInstruction(payer: PublicKey, params: QuoteVerifyParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    verify(params: QuoteVerifyParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
}
//# sourceMappingURL=verifierAccount.d.ts.map