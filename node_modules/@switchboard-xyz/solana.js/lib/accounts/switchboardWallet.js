import * as errors from "../errors.js";
import * as types from "../generated/attestation-program/index.js";
import { Mint } from "../mint.js";
import { SB_ATTESTATION_PID, } from "../SwitchboardProgram.js";
import { TransactionObject } from "../TransactionObject.js";
import { handleOptionalPubkeys, parseRawBuffer } from "../utils.js";
import { Account } from "./account.js";
import * as spl from "@solana/spl-token";
import { PublicKey, SystemProgram } from "@solana/web3.js";
import assert from "assert";
/**
 * Account holding a Verifiable Random Function result with a callback instruction for consuming on-chain pseudo-randomness.
 *
 * Data: {@linkcode types.SwitchboardWalletData}
 * Result: [u8;32]
 */
export class SwitchboardWallet extends Account {
    static accountName = "SwitchboardWallet";
    get tokenWallet() {
        return this.program.mint.getAssociatedAddress(this.publicKey);
    }
    static parseName(name) {
        let nameSeed;
        if (typeof name === "string") {
            nameSeed = new Uint8Array(Buffer.from(name, "utf-8")).slice(0, 32);
        }
        else if (name instanceof Uint8Array) {
            nameSeed = name;
        }
        else {
            nameSeed = name.toBytes();
        }
        return parseRawBuffer(nameSeed, 32);
    }
    static fromSeed(program, attestationQueue, authority, name) {
        const nameSeed = SwitchboardWallet.parseName(name);
        const walletPubkey = PublicKey.findProgramAddressSync([
            program.mint.address.toBytes(),
            attestationQueue.toBytes(),
            authority.toBytes(),
            nameSeed,
        ], program.attestationProgramId)[0];
        return new SwitchboardWallet(program, walletPubkey);
    }
    async loadData() {
        const accountInfos = await this.program.connection.getMultipleAccountsInfo([
            this.publicKey,
            this.tokenWallet,
        ]);
        const walletAccountInfo = accountInfos.shift();
        if (!walletAccountInfo) {
            throw new errors.AccountNotFoundError("SwitchboardWallet", this.publicKey);
        }
        const tokenAccountInfo = accountInfos.shift();
        if (!tokenAccountInfo) {
            throw new errors.AccountNotFoundError("SwitchboardWallet tokenAccount", this.tokenWallet);
        }
        assert(accountInfos.length === 0);
        if (!this.program.attestationProgramId.equals(walletAccountInfo.owner)) {
            throw new errors.IncorrectOwner(this.program.attestationProgramId, walletAccountInfo.owner);
        }
        const data = types.SwitchboardWallet.decode(walletAccountInfo.data);
        if (data === null) {
            throw new errors.AccountNotFoundError("SwitchboardWallet", this.publicKey);
        }
        const tokenWalletAccount = spl.unpackAccount(this.tokenWallet, tokenAccountInfo);
        return { ...data, tokenWalletAccount };
    }
    static async load(program, attestationQueue, authority, name) {
        const wallet = SwitchboardWallet.fromSeed(program, attestationQueue, authority, name);
        try {
            const walletState = await wallet.loadData();
            return [wallet, walletState];
        }
        catch { }
        return [wallet, undefined];
    }
    async getBalance() {
        const balance = await this.program.mint.fetchBalance(this.tokenWallet);
        if (balance === null) {
            throw new errors.AccountNotFoundError("SwitchboardWallet Escrow", this.tokenWallet);
        }
        return balance;
    }
    async getBalanceBN() {
        const balance = await this.program.mint.fetchBalanceBN(this.tokenWallet);
        if (balance === null) {
            throw new errors.AccountNotFoundError("SwitchboardWallet Escrow", this.tokenWallet);
        }
        return balance;
    }
    static async createInstruction(program, payer, attestationQueue, authority, name, maxLen, options) {
        const nameSeed = SwitchboardWallet.parseName(name);
        const switchboardWallet = SwitchboardWallet.fromSeed(program, attestationQueue, authority, nameSeed);
        const walletInitIxn = types.walletInit(program, { params: { name: Buffer.from(nameSeed) } }, {
            wallet: switchboardWallet.publicKey,
            mint: program.mint.address,
            authority: authority,
            attestationQueue: attestationQueue,
            tokenWallet: switchboardWallet.tokenWallet,
            payer: payer,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
            associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
        });
        return [
            switchboardWallet,
            new TransactionObject(payer, [walletInitIxn], [], options),
        ];
    }
    static async create(program, attestationQueue, authority, name, maxLen, options) {
        const [account, transaction] = await SwitchboardWallet.createInstruction(program, program.walletPubkey, attestationQueue, authority, name, maxLen, options);
        const txnSignature = await program.signAndSend(transaction, options);
        return [account, txnSignature];
    }
    async fundInstruction(payer, params, options) {
        const ixns = [];
        let funderPubkey = payer;
        if (params.funderAuthority) {
            funderPubkey = params.funderAuthority.publicKey;
        }
        // let transferAmount: BN | null = null;
        // if (params.transferAmount) {
        //   transferAmount = this.program.mint.toTokenAmountBN(params.transferAmount);
        // }
        // let wrapAmount: BN | null = null;
        // if (params.wrapAmount) {
        //   wrapAmount = this.program.mint.toTokenAmountBN(params.wrapAmount);
        // }
        let funderTokenWallet;
        if (params.funderTokenWallet) {
            funderTokenWallet = params.funderTokenWallet;
        }
        else if (params.transferAmount && params.transferAmount > 0) {
            funderTokenWallet = this.program.mint.getAssociatedAddress(funderPubkey);
            const funderTokenAccount = await this.program.mint.getAccount(funderTokenWallet);
            if (!funderTokenAccount) {
                // create ixn if account isnt initialized
                const [tokenWallet, tokenWalletInitIxns] = this.program.mint.createWrappedUserInstructions(payer, params.transferAmount, params.funderAuthority
                    ? params.funderAuthority.publicKey
                    : undefined);
                ixns.push(...tokenWalletInitIxns);
                funderTokenWallet = tokenWallet; // sanity check
            }
        }
        else {
            funderTokenWallet = SB_ATTESTATION_PID;
        }
        const walletState = await this.loadData();
        const ixn = types.walletFund(this.program, {
            params: {
                transferAmount: params.transferAmount
                    ? this.program.mint.toTokenAmountBN(params.transferAmount)
                    : null,
                wrapAmount: params.wrapAmount
                    ? this.program.mint.toTokenAmountBN(params.wrapAmount)
                    : null,
            },
        }, {
            wallet: this.publicKey,
            mint: this.program.mint.address,
            authority: walletState.authority,
            attestationQueue: walletState.attestationQueue,
            tokenWallet: this.tokenWallet,
            funderWallet: funderTokenWallet,
            funder: funderPubkey,
            state: this.program.attestationProgramState.publicKey,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
        });
        // add all resources so we can update their funding statuses
        ixn.keys.push(...(params?.resources ?? walletState.resources)
            .filter((r) => !PublicKey.default.equals(r))
            .map((r) => {
            return {
                pubkey: r,
                isSigner: false,
                isWritable: true,
            };
        }));
        ixns.push(handleOptionalPubkeys(ixn));
        return new TransactionObject(payer, ixns, params.funderAuthority ? [params.funderAuthority] : [], options);
    }
    async fund(params, options) {
        const transaction = await this.fundInstruction(this.program.walletPubkey, params, options);
        const txnSignature = await this.program.signAndSend(transaction, options);
        return txnSignature;
    }
    async wrapInstruction(payer, amount, options) {
        const walletState = await this.loadData();
        const ixn = types.walletFund(this.program, {
            params: {
                transferAmount: null,
                wrapAmount: this.program.mint.toTokenAmountBN(amount),
            },
        }, {
            wallet: this.publicKey,
            mint: walletState.mint,
            authority: walletState.authority,
            attestationQueue: walletState.attestationQueue,
            tokenWallet: this.tokenWallet,
            funderWallet: this.program.attestationProgramId,
            funder: payer,
            state: this.program.attestationProgramState.publicKey,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
        });
        ixn.keys.push(...walletState.resources
            .filter((r) => !PublicKey.default.equals(r))
            .map((r) => {
            return {
                pubkey: r,
                isSigner: false,
                isWritable: true,
            };
        }));
        return new TransactionObject(payer, [ixn], [], options);
    }
    async wrap(amount, options) {
        const transaction = await this.wrapInstruction(this.program.walletPubkey, amount, options);
        const txnSignature = await this.program.signAndSend(transaction, options);
        return txnSignature;
    }
    async withdrawInstruction(payer, amount, destinationWallet, options) {
        const walletState = await this.loadData();
        const mint = await Mint.load(this.program.provider, walletState.mint);
        let createTokenWalletIxn = undefined;
        // If the destination wallet doesnt exist, lets use the users associated token account
        let destinationTokenWallet = destinationWallet;
        if (!destinationTokenWallet) {
            destinationTokenWallet = mint.getAssociatedAddress(payer);
            const tokenAccount = await mint.getAccount(destinationTokenWallet);
            if (!tokenAccount) {
                createTokenWalletIxn = spl.createAssociatedTokenAccountInstruction(payer, destinationTokenWallet, payer, mint.address);
            }
        }
        else {
            const tokenAccount = await mint.getAccount(destinationTokenWallet);
            if (!tokenAccount) {
                throw new Error(`Destination wallet ${destinationTokenWallet.toBase58()} does not exist.`);
            }
        }
        const ixn = types.walletWithdraw(this.program, { params: { amount: this.program.mint.toTokenAmountBN(amount) } }, {
            wallet: this.publicKey,
            mint: walletState.mint,
            authority: walletState.authority,
            attestationQueue: walletState.attestationQueue,
            tokenWallet: this.tokenWallet,
            destinationWallet: destinationTokenWallet,
            state: this.program.attestationProgramState.publicKey,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
        });
        ixn.keys.push(...walletState.resources
            .filter((r) => !PublicKey.default.equals(r))
            .map((r) => {
            return {
                pubkey: r,
                isSigner: false,
                isWritable: true,
            };
        }));
        return new TransactionObject(payer, createTokenWalletIxn ? [createTokenWalletIxn, ixn] : [ixn], [], options);
    }
    async withdraw(amount, destinationWallet, options) {
        const transaction = await this.withdrawInstruction(this.program.walletPubkey, amount, destinationWallet, options);
        const txnSignature = await this.program.signAndSend(transaction, options);
        return txnSignature;
    }
}
