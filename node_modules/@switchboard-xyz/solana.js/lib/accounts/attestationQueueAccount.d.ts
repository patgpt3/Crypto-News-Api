import * as types from "../generated/attestation-program/index.js";
import type { SwitchboardProgram } from "../SwitchboardProgram.js";
import type { SendTransactionObjectOptions, TransactionObjectOptions } from "../TransactionObject.js";
import { TransactionObject } from "../TransactionObject.js";
import type { WithRequired } from "../types.js";
import { Account } from "./account.js";
import type { AttestationPermissionSetParams } from "./attestationPermissionAccount.js";
import { AttestationPermissionAccount } from "./attestationPermissionAccount.js";
import type { FunctionAccountInitParams } from "./functionAccount.js";
import { FunctionAccount } from "./functionAccount.js";
import type { SwitchboardWallet } from "./switchboardWallet.js";
import type { VerifierAccountInitParams } from "./verifierAccount.js";
import { VerifierAccount } from "./verifierAccount.js";
import type { PublicKey, TransactionSignature } from "@solana/web3.js";
import { Keypair } from "@solana/web3.js";
import { type RawBuffer } from "@switchboard-xyz/common";
/**
 *  Parameters for initializing an {@linkcode QueueAccount}
 */
export interface AttestationQueueAccountInitParams {
    /**
     *  Rewards to provide oracles and round openers on this queue.
     */
    reward: number;
    /**
     *  @TODO: document this param
     */
    allowAuthorityOverrideAfter: number;
    /**
     *  @TODO: document this param
     */
    maxQuoteVerificationAge: number;
    /**
     *  A flag indicating whether usage authority is required to heartbeat.
     *
     *  @default false
     */
    requireAuthorityHeartbeatPermission: boolean;
    /**
     *  A flag indicating whether usage permissions are required.
     *
     *  @default false
     */
    requireUsagePermissions: boolean;
    /**
     *  Time period (in seconds) we should remove an oracle after if no response.
     *
     *  @default 180
     */
    nodeTimeout?: number;
    /**
     *  A keypair to be used to address this account
     *
     *  @default Keypair.generate()
     */
    keypair?: Keypair;
    /**
     *  An authority to be used to control this account.
     *
     *  @default payer
     */
    authority?: Keypair;
}
/**
 *  Parameters for an {@linkcode types.queueAddMrEnclave} instruction.
 */
export interface AttestationQueueAddMrEnclaveParams {
    mrEnclave: RawBuffer;
    authority?: Keypair;
}
/**
 *  Parameters for an {@linkcode types.queueRemoveMrEnclave} instruction.
 */
export interface AttestationQueueRemoveMrEnclaveParams {
    mrEnclave: RawBuffer;
    authority?: Keypair;
}
export type CreateQueueQuoteParams = Omit<VerifierAccountInitParams, "queueAccount"> & Partial<AttestationPermissionSetParams> & {
    queueAuthorityPubkey?: PublicKey;
} & {
    createPermissions?: boolean;
};
export type CreateFunctionParams = Omit<FunctionAccountInitParams, "attestationQueue"> & Partial<AttestationPermissionSetParams> & {
    queueAuthorityPubkey?: PublicKey;
};
/**
 * Account type representing an oracle queue's configuration along with a buffer account holding a
 * list of oracles that are actively heartbeating.
 *
 * A QueueAccount is responsible for allocating update requests to it's round robin queue of
 * {@linkcode OracleAccount}'s.
 *
 * Data: {@linkcode types.AttestationQueueAccountData}
 *
 * Buffer: {@linkcode QueueDataBuffer}
 */
export declare class AttestationQueueAccount extends Account<types.AttestationQueueAccountData> {
    static accountName: string;
    /**
     *  Retrieve and decode the {@linkcode types.AttestationQueueAccountData} stored in this account.
     */
    loadData(): Promise<types.AttestationQueueAccountData>;
    /**
     *  Load an existing {@linkcode AttestationQueueAccount} with its current on-chain state
     */
    static load(program: SwitchboardProgram, address: PublicKey | string): Promise<[AttestationQueueAccount, types.AttestationQueueAccountData]>;
    static createInstruction(program: SwitchboardProgram, payer: PublicKey, params: WithRequired<AttestationQueueAccountInitParams, "keypair">, options?: TransactionObjectOptions): [AttestationQueueAccount, TransactionObject];
    static create(program: SwitchboardProgram, params: AttestationQueueAccountInitParams, options?: SendTransactionObjectOptions): Promise<[AttestationQueueAccount, TransactionSignature]>;
    createVerifierInstruction(payer: PublicKey, params: CreateQueueQuoteParams, options?: TransactionObjectOptions): Promise<[VerifierAccount, TransactionObject]>;
    createVerifier(params: CreateQueueQuoteParams, options?: SendTransactionObjectOptions): Promise<[VerifierAccount, TransactionSignature]>;
    createFunctionInstruction(payer: PublicKey, params: CreateFunctionParams, wallet?: SwitchboardWallet, options?: TransactionObjectOptions): Promise<[FunctionAccount, TransactionObject]>;
    createFunction(params: CreateFunctionParams, wallet?: SwitchboardWallet, options?: SendTransactionObjectOptions): Promise<[FunctionAccount, TransactionSignature]>;
    /**
     * Find the index of an enclave in an array and return -1 if not found
     */
    static findEnclaveIdx(enclaves: Array<Uint8Array>, enclave: Uint8Array): number;
    addMrEnclaveInstruction(payer: PublicKey, params: AttestationQueueAddMrEnclaveParams, options?: TransactionObjectOptions): TransactionObject;
    addMrEnclave(params: AttestationQueueAddMrEnclaveParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    removeMrEnclaveInstruction(payer: PublicKey, params: AttestationQueueRemoveMrEnclaveParams, options?: TransactionObjectOptions): TransactionObject;
    removeMrEnclave(params: AttestationQueueRemoveMrEnclaveParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    /**
     * Create a new attestation queue for internal testing
     * - Creates AttestationQueue account
     * - Creates a Quote verifier
     * - Sets the quote verifier secured signer
     * - Adds Quote verifier to the queue
     */
    static bootstrapNewQueue(program: SwitchboardProgram, params?: CreateBootstrappedQueueParams, options?: SendTransactionObjectOptions): Promise<BootstrappedAttestationQueue & {
        signatures?: Array<TransactionSignature>;
    }>;
    loadVerifierOracles(_attestationQueue?: types.AttestationQueueAccountData): Promise<VerifierAccountAndState[]>;
}
type VerifierAccountAndState = {
    publicKey: PublicKey;
    state: types.VerifierAccountData;
};
export type CreateBootstrappedQueueParams = AttestationQueueAccountInitParams & {
    verifierEnclave: RawBuffer;
    registryKey?: RawBuffer;
    enclaveSigner?: Keypair;
};
export type BootstrappedAttestationQueue = {
    program: SwitchboardProgram;
    attestationQueue: {
        account: AttestationQueueAccount;
        publicKey: PublicKey;
        authority: PublicKey;
    };
    verifier: {
        account: VerifierAccount;
        publicKey: PublicKey;
        permissionAccount: AttestationPermissionAccount;
        signer: Keypair;
    };
};
export {};
//# sourceMappingURL=attestationQueueAccount.d.ts.map