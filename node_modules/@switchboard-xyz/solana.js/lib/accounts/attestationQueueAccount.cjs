"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttestationQueueAccount = void 0;
const errors = __importStar(require("../errors.cjs"));
const types = __importStar(require("../generated/attestation-program/index.cjs"));
const SwitchboardProgram_js_1 = require("../SwitchboardProgram.cjs");
const TransactionObject_js_1 = require("../TransactionObject.cjs");
const utils_js_1 = require("../utils.cjs");
const account_js_1 = require("./account.cjs");
const attestationPermissionAccount_js_1 = require("./attestationPermissionAccount.cjs");
const functionAccount_js_1 = require("./functionAccount.cjs");
const verifierAccount_js_1 = require("./verifierAccount.cjs");
const anchor = __importStar(require("@coral-xyz/anchor"));
const web3_js_1 = require("@solana/web3.js");
const common_1 = require("@switchboard-xyz/common");
/**
 * Account type representing an oracle queue's configuration along with a buffer account holding a
 * list of oracles that are actively heartbeating.
 *
 * A QueueAccount is responsible for allocating update requests to it's round robin queue of
 * {@linkcode OracleAccount}'s.
 *
 * Data: {@linkcode types.AttestationQueueAccountData}
 *
 * Buffer: {@linkcode QueueDataBuffer}
 */
class AttestationQueueAccount extends account_js_1.Account {
    static accountName = "AttestationQueueAccountData";
    /**
     *  Retrieve and decode the {@linkcode types.AttestationQueueAccountData} stored in this account.
     */
    async loadData() {
        const data = await types.AttestationQueueAccountData.fetch(this.program, this.publicKey);
        if (data)
            return data;
        throw new errors.AccountNotFoundError("AttestationQueue", this.publicKey);
    }
    /**
     *  Load an existing {@linkcode AttestationQueueAccount} with its current on-chain state
     */
    static async load(program, address) {
        const queueAccount = new AttestationQueueAccount(program, address);
        const state = await queueAccount.loadData();
        return [queueAccount, state];
    }
    static createInstruction(program, payer, params, options) {
        const instruction = types.attestationQueueInit(program, {
            params: {
                reward: params.reward,
                allowAuthorityOverrideAfter: params.allowAuthorityOverrideAfter,
                maxQuoteVerificationAge: params.maxQuoteVerificationAge,
                nodeTimeout: params.nodeTimeout ?? 180,
                requireAuthorityHeartbeatPermission: params.requireAuthorityHeartbeatPermission ?? false,
                requireUsagePermissions: params.requireUsagePermissions ?? false,
            },
        }, {
            queue: params.keypair.publicKey,
            authority: params.authority ? params.authority.publicKey : payer,
            payer: payer,
            systemProgram: web3_js_1.SystemProgram.programId,
        });
        return [
            new AttestationQueueAccount(program, params.keypair.publicKey),
            new TransactionObject_js_1.TransactionObject(payer, [instruction], [params.keypair], options),
        ];
    }
    static async create(program, params, options) {
        const queueKeypair = params.keypair ?? web3_js_1.Keypair.generate();
        await program.verifyNewKeypair(queueKeypair);
        const [account, txnObject] = this.createInstruction(program, program.walletPubkey, { ...params, keypair: queueKeypair }, options);
        return [account, await program.signAndSend(txnObject, options)];
    }
    async createVerifierInstruction(payer, params, options) {
        const authority = params.authority ?? payer;
        const queueAuthority = params.queueAuthorityPubkey ?? (await this.loadData()).authority;
        const [verifierAccount, quoteInit] = await verifierAccount_js_1.VerifierAccount.createInstruction(this.program, payer, { ...params, queueAccount: this, authority }, options);
        if (!params.createPermissions && !params.enable) {
            return [verifierAccount, quoteInit];
        }
        const [permissionAccount, permissionInit] = attestationPermissionAccount_js_1.AttestationPermissionAccount.createInstruction(this.program, payer, {
            granter: this.publicKey,
            grantee: verifierAccount.publicKey,
            authority: queueAuthority,
        }, options);
        if (params.enable) {
            const permissionSet = permissionAccount.setInstruction(payer, {
                enable: true,
                permission: new types.SwitchboardAttestationPermission.PermitNodeheartbeat(),
                queue: this.publicKey,
                enclave: verifierAccount.publicKey,
            });
            permissionInit.combine(permissionSet);
        }
        return [verifierAccount, quoteInit.combine(permissionInit)];
    }
    async createVerifier(params, options) {
        const [account, txnObject] = await this.createVerifierInstruction(this.program.walletPubkey, params, options);
        return [account, await this.program.signAndSend(txnObject, options)];
    }
    async createFunctionInstruction(payer, params, wallet, options) {
        const queueAuthority = params.queueAuthorityPubkey ?? (await this.loadData()).authority;
        const [functionAccount, functionInit] = await functionAccount_js_1.FunctionAccount.createInstruction(this.program, payer, { ...params, attestationQueue: this }, wallet, options);
        if (params.enable) {
            const permissionSet = types.attestationPermissionSet(this.program, {
                params: {
                    permission: types.SwitchboardAttestationPermission.PermitQueueUsage
                        .discriminator,
                    enable: params.enable,
                },
            }, {
                permission: SwitchboardProgram_js_1.SB_ATTESTATION_PID,
                authority: queueAuthority,
                attestationQueue: this.publicKey,
                grantee: functionAccount.publicKey,
            });
            functionInit.add(permissionSet);
        }
        return [functionAccount, functionInit];
    }
    async createFunction(params, wallet, options) {
        const [account, txnObject] = await this.createFunctionInstruction(this.program.walletPubkey, params, wallet, options);
        return [account, await this.program.signAndSend(txnObject, options)];
    }
    /**
     * Find the index of an enclave in an array and return -1 if not found
     */
    static findEnclaveIdx(enclaves, enclave) {
        for (const [n, e] of enclaves.entries()) {
            if (Buffer.compare(e, enclave) === 0) {
                return n;
            }
        }
        return -1;
    }
    addMrEnclaveInstruction(payer, params, options) {
        const authority = params.authority?.publicKey ?? payer;
        const signers = params.authority ? [params.authority] : [];
        const instruction = types.attestationQueueAddMrEnclave(this.program, {
            params: { mrEnclave: Array.from((0, common_1.parseRawMrEnclave)(params.mrEnclave)) },
        }, { authority, queue: this.publicKey });
        return new TransactionObject_js_1.TransactionObject(payer, [instruction], signers, options);
    }
    async addMrEnclave(params, options) {
        return await this.program.signAndSend(this.addMrEnclaveInstruction(this.program.walletPubkey, params, options), options);
    }
    removeMrEnclaveInstruction(payer, params, options) {
        const authority = params.authority?.publicKey ?? payer;
        const signers = params.authority ? [params.authority] : [];
        const instruction = types.attestationQueueRemoveMrEnclave(this.program, {
            params: { mrEnclave: Array.from((0, common_1.parseRawMrEnclave)(params.mrEnclave)) },
        }, { authority, queue: this.publicKey });
        return new TransactionObject_js_1.TransactionObject(payer, [instruction], signers, options);
    }
    async removeMrEnclave(params, options) {
        return await this.program.signAndSend(this.removeMrEnclaveInstruction(this.program.walletPubkey, params, options), options);
    }
    /**
     * Create a new attestation queue for internal testing
     * - Creates AttestationQueue account
     * - Creates a Quote verifier
     * - Sets the quote verifier secured signer
     * - Adds Quote verifier to the queue
     */
    static async bootstrapNewQueue(program, params, options) {
        const authority = params?.authority ?? program.wallet.payer;
        const attestationQueueKeypair = params?.keypair ?? web3_js_1.Keypair.generate();
        const verifierKeypair1 = web3_js_1.Keypair.generate();
        const verifierSigner1 = params?.enclaveSigner ?? web3_js_1.Keypair.generate();
        const ixns = [];
        const signers = [
            authority,
            attestationQueueKeypair,
            verifierKeypair1,
            verifierSigner1,
        ];
        // create attestation queue
        ixns.push(types.attestationQueueInit(program, {
            params: {
                reward: params?.reward ?? 0,
                allowAuthorityOverrideAfter: params?.allowAuthorityOverrideAfter ?? 300,
                maxQuoteVerificationAge: params?.maxQuoteVerificationAge ?? 604800,
                nodeTimeout: params?.nodeTimeout ?? 180,
                requireAuthorityHeartbeatPermission: params?.requireAuthorityHeartbeatPermission ?? false,
                requireUsagePermissions: params?.requireUsagePermissions ?? false,
            },
        }, {
            queue: attestationQueueKeypair.publicKey,
            authority: authority.publicKey,
            payer: authority.publicKey,
            systemProgram: web3_js_1.SystemProgram.programId,
        }));
        if (params?.verifierEnclave) {
            // add mrEnclave
            ixns.push(types.attestationQueueAddMrEnclave(program, {
                params: {
                    mrEnclave: Array.from((0, common_1.parseRawMrEnclave)(params?.verifierEnclave ?? "", true)),
                },
            }, {
                queue: attestationQueueKeypair.publicKey,
                authority: authority.publicKey,
            }));
        }
        // create quote #1
        ixns.push(types.verifierInit(program, {
            params: {
                registryKey: (0, utils_js_1.parseRawBuffer)(params?.registryKey ?? "", 64),
            },
        }, {
            verifier: verifierKeypair1.publicKey,
            attestationQueue: attestationQueueKeypair.publicKey,
            queueAuthority: authority.publicKey,
            authority: authority.publicKey,
            payer: authority.publicKey,
            systemProgram: web3_js_1.SystemProgram.programId,
        }));
        // create & set quote #1 permissions
        const verifierQuotePermissions1 = attestationPermissionAccount_js_1.AttestationPermissionAccount.fromSeed(program, authority.publicKey, attestationQueueKeypair.publicKey, verifierKeypair1.publicKey);
        ixns.push(types.attestationPermissionInit(program, { params: {} }, {
            permission: verifierQuotePermissions1.publicKey,
            attestationQueue: attestationQueueKeypair.publicKey,
            node: verifierKeypair1.publicKey,
            authority: authority.publicKey,
            payer: authority.publicKey,
            systemProgram: web3_js_1.SystemProgram.programId,
        }));
        ixns.push(types.attestationPermissionSet(program, {
            params: {
                permission: 1,
                enable: true,
            },
        }, {
            permission: verifierQuotePermissions1.publicKey,
            authority: authority.publicKey,
            attestationQueue: attestationQueueKeypair.publicKey,
            grantee: verifierKeypair1.publicKey,
        }));
        // set quote #1 securedSigner
        // ixns.push(
        //   types.verifierQuoteRotate(
        //     program,
        //     {
        //       params: {
        //         registryKey: Array.from(
        //           parseRawBuffer(params?.registryKey ?? "", 64)
        //         ),
        //       },
        //     },
        //     {
        //       verifier: verifierKeypair1.publicKey,
        //       authority: authority.publicKey,
        //       enclaveSigner: verifierSigner1.publicKey,
        //       attestationQueue: attestationQueueKeypair.publicKey,
        //     }
        //   )
        // );
        // yeet out of the wrapper so we can use the on-chain IDL
        const attestationProgram = await program.attestationProgram;
        ixns.push(await attestationProgram.methods
            .verifierQuoteRotate({
            registryKey: Array.from((0, utils_js_1.parseRawBuffer)(params?.registryKey ?? "", 64)),
            secpPubkey: null,
        })
            .accounts({
            verifier: verifierKeypair1.publicKey,
            authority: authority.publicKey,
            enclaveSigner: verifierSigner1.publicKey,
            attestationQueue: attestationQueueKeypair.publicKey,
        })
            .instruction());
        // quote #1 heartbeat
        ixns.push(await attestationProgram.methods
            .verifierHeartbeat({
            secpPubkey: null,
        })
            .accounts({
            verifier: verifierKeypair1.publicKey,
            verifierSigner: verifierSigner1.publicKey,
            attestationQueue: attestationQueueKeypair.publicKey,
            queueAuthority: authority.publicKey,
            gcNode: verifierKeypair1.publicKey,
            permission: verifierQuotePermissions1.publicKey,
        })
            .instruction());
        // ixns.push(
        //   types.verifierHeartbeat(
        //     program,
        //     { params: {} },
        //     {
        //       verifier: verifierKeypair1.publicKey,
        //       verifierSigner: verifierSigner1.publicKey,
        //       attestationQueue: attestationQueueKeypair.publicKey,
        //       queueAuthority: authority.publicKey,
        //       gcNode: verifierKeypair1.publicKey,
        //       permission: verifierQuotePermissions1.publicKey,
        //     }
        //   )
        // );
        const txns = TransactionObject_js_1.TransactionObject.packIxns(program.walletPubkey, ixns, signers, options);
        const signatures = await program.signAndSendAll(txns, options);
        const attestationQueueAccount = new AttestationQueueAccount(program, attestationQueueKeypair.publicKey);
        return {
            program: program,
            attestationQueue: {
                account: attestationQueueAccount,
                publicKey: attestationQueueAccount.publicKey,
                authority: authority.publicKey,
            },
            verifier: {
                account: new verifierAccount_js_1.VerifierAccount(program, verifierKeypair1.publicKey),
                publicKey: verifierKeypair1.publicKey,
                permissionAccount: verifierQuotePermissions1,
                signer: verifierSigner1,
            },
            signatures,
        };
    }
    async loadVerifierOracles(_attestationQueue) {
        const attestationQueue = _attestationQueue ?? (await this.loadData());
        const verifierPubkeys = attestationQueue.data.slice(0, attestationQueue.dataLen);
        if (verifierPubkeys.length === 0) {
            return [];
        }
        const data = [];
        const accounts = await anchor.utils.rpc.getMultipleAccounts(this.program.provider.connection, verifierPubkeys);
        for (const account of accounts) {
            if (!account)
                continue;
            data.push({
                publicKey: account.publicKey,
                state: types.VerifierAccountData.decode(account.account.data),
            });
        }
        return data;
    }
}
exports.AttestationQueueAccount = AttestationQueueAccount;
