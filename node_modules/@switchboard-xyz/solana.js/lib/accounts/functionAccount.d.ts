/// <reference types="node" resolution-mode="require"/>
import { Account } from "../accounts/account.js";
import * as types from "../generated/attestation-program/index.js";
import type { SwitchboardProgram } from "../SwitchboardProgram.js";
import type { SendTransactionObjectOptions, TransactionObjectOptions } from "../TransactionObject.js";
import { TransactionObject } from "../TransactionObject.js";
import type { FunctionRequestAccountInitParams, FunctionRoutineAccountInitParams, FunctionServiceAccountInitParams, SwitchboardWalletFundParams, VerifierAccount } from "./index.js";
import { AttestationQueueAccount, FunctionRequestAccount, FunctionRoutineAccount, FunctionServiceAccount, SwitchboardWallet } from "./index.js";
import * as anchor from "@coral-xyz/anchor";
import type { AccountInfo, AddressLookupTableAccount, Keypair, SendOptions, TransactionInstruction, TransactionSignature } from "@solana/web3.js";
import { PublicKey } from "@solana/web3.js";
import type { RawBuffer } from "@switchboard-xyz/common";
import { BN } from "@switchboard-xyz/common";
export type ContainerRegistryType = "dockerhub" | "ipfs";
export type FunctionAccountInitSeeds = {
    recentSlot?: number;
    creatorSeed?: RawBuffer;
};
/**
 *  Parameters for initializing a {@linkcode FunctionAccount}
 */
export type FunctionAccountInitParams = FunctionAccountInitSeeds & {
    name?: string;
    metadata?: string;
    container: string;
    version?: string;
    containerRegistry?: ContainerRegistryType;
    mrEnclave?: Buffer | Uint8Array | number[];
    requestsDisabled?: boolean;
    requestsRequireAuthorization?: boolean;
    requestsFee?: number;
    routinesDisabled?: boolean;
    routinesRequireAuthorization?: boolean;
    routinesFee?: number;
    enableServices?: boolean;
    lockServicesDisabled?: boolean;
    servicesRequireAuthorization?: boolean;
    servicesSignerRotationInterval?: number;
    servicesFee?: number;
    attestationQueue: AttestationQueueAccount;
    /**
     *  An authority to be used to control this account.
     *
     *  @default payer
     */
    authority?: PublicKey;
};
/**
 *  Parameters for setting a {@linkcode FunctionAccount} config
 */
export interface FunctionSetConfigParams {
    name?: string;
    metadata?: string;
    container?: string;
    containerRegistry?: ContainerRegistryType;
    version?: string;
    schedule?: string;
    mrEnclaves?: Array<RawBuffer>;
    requestsDisabled?: boolean;
    requestsRequireAuthorization?: boolean;
    requestsFee?: number;
    routinesDisabled?: boolean;
    lockRoutinesDisabled?: boolean;
    routinesRequireAuthorization?: boolean;
    routinesFee?: number;
    servicesDisabled?: boolean;
    lockServicesDisabled?: boolean;
    servicesRequireAuthorization?: boolean;
    servicesSignerRotationInterval?: number;
    servicesFee?: number;
    authority?: Keypair;
}
/**
 *  Parameters for setting a {@linkcode FunctionAccount} escrow
 */
export interface FunctionSetEscrowParams {
    authority?: Keypair;
    newEscrow: SwitchboardWallet;
    newEscrowAuthority?: Keypair;
}
/**
 *  Parameters for setting a {@linkcode FunctionAccount} authority
 */
export interface FunctionSetAuthorityParams {
    authority?: Keypair;
    newAuthority: PublicKey;
    walletAuthority?: Keypair;
}
/**
 *  Parameters for setting a {@linkcode types.functionClose} authority
 */
export interface FunctionCloseAccountParams {
    authority?: Keypair;
}
/**
 *  Parameters for an {@linkcode types.functionVerify} instruction.
 */
export interface FunctionVerifySyncParams {
    observedTime: BN;
    nextAllowedTimestamp: BN;
    isFailure: boolean;
    mrEnclave: Uint8Array;
    escrowWallet: PublicKey;
    functionEnclaveSigner: PublicKey;
    attestationQueue: PublicKey;
    attestationQueueAuthority: PublicKey;
    quoteVerifier: PublicKey;
    quoteVerifierEnclaveSigner: PublicKey;
    receiver: PublicKey;
}
/**
 *  Parameters for an {@linkcode types.functionVerify} instruction.
 */
export interface FunctionVerifyParams {
    observedTime: BN;
    nextAllowedTimestamp: BN;
    isFailure: boolean;
    mrEnclave: Uint8Array;
    verifier: VerifierAccount;
    verifierEnclaveSigner: PublicKey;
    functionEnclaveSigner: PublicKey;
    receiver: PublicKey;
    fnState?: types.FunctionAccountData;
    attestationQueueAuthority?: PublicKey;
}
/**
 *  Parameters for an {@linkcode types.functionTrigger} instruction.
 */
export interface FunctionTriggerParams {
    authority?: Keypair;
}
export type CreateFunctionRequestParams = Omit<FunctionRequestAccountInitParams, "functionAccount"> & {
    keypair?: Keypair;
};
export type CreateFunctionRoutineParams = Omit<FunctionRoutineAccountInitParams, "functionAccount"> & {
    keypair?: Keypair;
};
export type CreateFunctionServiceParams = Omit<FunctionServiceAccountInitParams, "functionAccount"> & {
    keypair?: Keypair;
};
/**
 * Account type representing a Switchboard Function.
 *
 * Data: {@linkcode types.FunctionAccountData}
 */
export declare class FunctionAccount extends Account<types.FunctionAccountData> {
    static accountName: string;
    private _wallet;
    /**
     *  Returns the functions's name buffer in a stringified format.
     */
    static getName: (functionState: types.FunctionAccountData) => string;
    /**
     *  Returns the functions's metadata buffer in a stringified format.
     */
    static getMetadata: (functionState: types.FunctionAccountData) => string;
    get wallet(): Promise<SwitchboardWallet>;
    set wallet(_wallet: Promise<SwitchboardWallet>);
    static fromSeed(program: SwitchboardProgram, creatorSeed: Uint8Array, recentSlot: BN): FunctionAccount;
    getBalance(): Promise<number>;
    getBalanceBN(): Promise<BN>;
    /**
     *  Retrieve and decode the {@linkcode types.FunctionAccountData} stored in this account.
     */
    loadData(): Promise<types.FunctionAccountData>;
    /**
     *  Decode the {@linkcode types.FunctionAccountData} stored in this account.
     */
    static decode(program: SwitchboardProgram, accountInfo: AccountInfo<Buffer>): Promise<[FunctionAccount, types.FunctionAccountData]>;
    /**
     *  Load an existing {@linkcode FunctionAccount} with its current on-chain state
     */
    static load(program: SwitchboardProgram, address: PublicKey | string): Promise<[FunctionAccount, types.FunctionAccountData]>;
    static createInstruction(program: SwitchboardProgram, payer: PublicKey, params: FunctionAccountInitParams, wallet?: SwitchboardWallet, options?: TransactionObjectOptions): Promise<[FunctionAccount, TransactionObject]>;
    static create(program: SwitchboardProgram, params: FunctionAccountInitParams, wallet?: SwitchboardWallet, options?: SendTransactionObjectOptions): Promise<[FunctionAccount, TransactionSignature]>;
    createRequestInstruction(payer: PublicKey, params: CreateFunctionRequestParams, options?: TransactionObjectOptions): Promise<[FunctionRequestAccount, TransactionObject]>;
    createRequest(params: CreateFunctionRequestParams, options?: SendTransactionObjectOptions): Promise<[FunctionRequestAccount, TransactionSignature]>;
    createRoutineInstruction(payer: PublicKey, params: CreateFunctionRoutineParams, wallet?: SwitchboardWallet, options?: TransactionObjectOptions): Promise<[FunctionRoutineAccount, TransactionObject]>;
    createRoutine(params: CreateFunctionRoutineParams, wallet?: SwitchboardWallet, options?: SendTransactionObjectOptions): Promise<[FunctionRoutineAccount, TransactionSignature]>;
    createServiceInstruction(payer: PublicKey, params: CreateFunctionServiceParams, wallet?: SwitchboardWallet, options?: TransactionObjectOptions): Promise<[FunctionServiceAccount, TransactionObject]>;
    createService(params: CreateFunctionServiceParams, wallet?: SwitchboardWallet, options?: SendTransactionObjectOptions): Promise<[FunctionServiceAccount, TransactionSignature]>;
    setConfigInstruction(payer: PublicKey, params: FunctionSetConfigParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    setConfig(params: FunctionSetConfigParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    static hasMrEnclave(mrEnclaves: Array<number[]>, targetMrEnclave: number[] | Uint8Array): boolean;
    addMrEnclaveInstruction(payer: PublicKey, mrEnclave: number[] | Uint8Array, params?: {
        authority?: Keypair;
        functionState?: types.FunctionAccountData;
        newVersion?: string;
        force?: boolean;
    }, options?: TransactionObjectOptions): Promise<TransactionObject>;
    addMrEnclave(mrEnclave: number[] | Uint8Array, params?: {
        authority?: Keypair;
        functionState?: types.FunctionAccountData;
        newVersion?: string;
        force?: boolean;
    }, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    /**
     * Try to add a MrEnclave to the function config, if it is not already present. Returns undefined
     * if MrEnclave is already in the config.
     */
    tryAddMrEnclave(mrEnclave: number[] | Uint8Array, params?: {
        authority?: Keypair;
        functionState?: types.FunctionAccountData;
        force?: boolean;
    }, options?: SendTransactionObjectOptions): Promise<TransactionSignature | undefined>;
    setEscrowInstruction(payer: PublicKey, params: FunctionSetEscrowParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    setEscrow(params: FunctionSetEscrowParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    setAuthorityInstruction(payer: PublicKey, params: FunctionSetAuthorityParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    setAuthority(params: FunctionSetAuthorityParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    resetEscrowInstruction(payer: PublicKey, authority?: Keypair, options?: TransactionObjectOptions): Promise<TransactionObject>;
    resetEscrow(authority?: Keypair, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    fundInstruction(payer: PublicKey, params: SwitchboardWalletFundParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    fund(params: SwitchboardWalletFundParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    wrapInstruction(payer: PublicKey, amount: number, options?: TransactionObjectOptions): Promise<TransactionObject>;
    wrap(amount: number, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    withdrawInstruction(payer: PublicKey, amount: number, destinationWallet?: PublicKey, options?: TransactionObjectOptions): Promise<TransactionObject>;
    withdraw(amount: number, destinationWallet?: PublicKey, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    closeAccountInstruction(payer: PublicKey, params: FunctionCloseAccountParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    closeAccount(params: FunctionCloseAccountParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    verifyInstructionSync(params: FunctionVerifySyncParams): TransactionInstruction;
    verifyInstruction(params: FunctionVerifyParams): Promise<TransactionInstruction>;
    verifyTransaction(params: FunctionVerifyParams): Promise<anchor.web3.VersionedTransaction>;
    verify(params: {
        observedTime: BN;
        nextAllowedTimestamp: BN;
        isFailure: boolean;
        mrEnclave: Uint8Array;
        verifier: VerifierAccount;
        verifierEnclaveSigner: Keypair;
        functionEnclaveSigner: Keypair;
        receiver: PublicKey;
        fnState?: types.FunctionAccountData;
        attestationQueueAuthority?: PublicKey;
    }, options?: SendOptions): Promise<TransactionSignature>;
    triggerInstruction(payer: PublicKey, params?: FunctionTriggerParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    trigger(params?: FunctionTriggerParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    static decodeAddressLookup(lookupTable: AddressLookupTableAccount): {
        systemProgram: anchor.web3.PublicKey;
        tokenProgram: anchor.web3.PublicKey;
        assocatedTokenProgram: anchor.web3.PublicKey;
        sysVarRent: anchor.web3.PublicKey;
        sysVarRecentBlockhashes: anchor.web3.PublicKey;
        sysVarInstructions: anchor.web3.PublicKey;
        sysVarSlotHashes: anchor.web3.PublicKey;
        sysVarSlotHistory: anchor.web3.PublicKey;
        switchboardProgram: anchor.web3.PublicKey;
        attestationProgram: anchor.web3.PublicKey;
        attestationQueuePubkey: anchor.web3.PublicKey;
        functionPubkey: anchor.web3.PublicKey;
        functionAuthorityPubkey: anchor.web3.PublicKey;
        mintPubkey: anchor.web3.PublicKey;
        walletPubkey: anchor.web3.PublicKey;
        escrowPubkey: anchor.web3.PublicKey;
    };
    static getVerificationStatus(state: types.FunctionAccountData): types.VerificationStatusKind;
}
//# sourceMappingURL=functionAccount.d.ts.map