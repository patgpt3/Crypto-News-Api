"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerifierAccount = exports.QUOTE_SEED = void 0;
const errors = __importStar(require("../errors.cjs"));
const types = __importStar(require("../generated/attestation-program/index.cjs"));
const TransactionObject_js_1 = require("../TransactionObject.cjs");
const utils_js_1 = require("../utils.cjs");
const account_js_1 = require("./account.cjs");
const index_js_1 = require("./index.cjs");
const web3_js_1 = require("@solana/web3.js");
const common_1 = require("@switchboard-xyz/common");
exports.QUOTE_SEED = "QuoteAccountData";
/**
 * Account type representing a Switchboard Attestation quote.
 *
 * Data: {@linkcode types.VerifierAccountData}
 */
class VerifierAccount extends account_js_1.Account {
    static accountName = "VerifierAccountData";
    /**
     *  Load an existing {@linkcode VerifierAccount} with its current on-chain state
     */
    static async load(program, address) {
        const verifierAccount = new VerifierAccount(program, address);
        const state = await verifierAccount.loadData();
        return [verifierAccount, state];
    }
    /**
     * Finds the {@linkcode VerifierAccount} from the seed from which it was generated.
     *
     * Only applicable for VerifierAccounts tied to a {@linkcode FunctionAccount}. Enclaves can also be generated from a keypair.
     *
     * @return VerifierAccount and PDA bump tuple.
     */
    static fromSeed(program, functionPubkey) {
        const [publicKey, bump] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from(exports.QUOTE_SEED), functionPubkey.toBytes()], program.attestationProgramId);
        return new VerifierAccount(program, publicKey);
    }
    /**
     * Create a transaction object to initialize a quote account.
     */
    static async createInstruction(program, payer, params, options) {
        const verifierKeypair = params.keypair ?? web3_js_1.Keypair.generate();
        await program.verifyNewKeypair(verifierKeypair);
        const queueData = await params.queueAccount.loadData();
        const registryKey = Array.from(params.registryKey)
            .concat(Array(64).fill(0))
            .slice(0, 64);
        const instruction = types.verifierInit(program, { params: { registryKey } }, {
            verifier: verifierKeypair.publicKey,
            attestationQueue: params.queueAccount.publicKey,
            queueAuthority: queueData.authority,
            authority: params.authority ?? payer,
            payer,
            systemProgram: web3_js_1.SystemProgram.programId,
        });
        return [
            new VerifierAccount(program, verifierKeypair.publicKey),
            new TransactionObject_js_1.TransactionObject(payer, [instruction], [verifierKeypair], options),
        ];
    }
    static async create(program, params, options) {
        const [account, txnObject] = await this.createInstruction(program, program.walletPubkey, params, options);
        const txSignature = await program.signAndSend(txnObject, options);
        return [account, txSignature];
    }
    getPermissionAccount(queuePubkey, queueAuthority, owner) {
        return index_js_1.AttestationPermissionAccount.fromSeed(this.program, queueAuthority, queuePubkey, owner);
    }
    static getVerificationStatus(state) {
        switch (state.enclave.verificationStatus) {
            case types.VerificationStatus.None.discriminator:
                return new types.VerificationStatus.None();
            case types.VerificationStatus.VerificationPending.discriminator:
                return new types.VerificationStatus.VerificationPending();
            case types.VerificationStatus.VerificationFailure.discriminator:
                return new types.VerificationStatus.VerificationFailure();
            case types.VerificationStatus.VerificationSuccess.discriminator:
                return new types.VerificationStatus.VerificationSuccess();
            case types.VerificationStatus.VerificationOverride.discriminator:
                return new types.VerificationStatus.VerificationOverride();
        }
        throw new Error(`Failed to get the verification status, expected [${types.VerificationStatus.None.discriminator}, ${types.VerificationStatus.VerificationPending.discriminator}, ${types.VerificationStatus.VerificationFailure.discriminator}, ${types.VerificationStatus.VerificationSuccess.discriminator}], or ${types.VerificationStatus.VerificationOverride.discriminator}], received ${state.enclave.verificationStatus}`);
    }
    /**
     *  Retrieve and decode the {@linkcode types.VerifierAccountData} stored in this account.
     */
    async loadData() {
        const data = await types.VerifierAccountData.fetch(this.program, this.publicKey);
        if (data)
            return data;
        throw new errors.AccountNotFoundError("Verifier", this.publicKey);
    }
    heartbeatInstruction(params) {
        const instruction = types.verifierHeartbeat(this.program, { params: {} }, {
            verifier: this.publicKey,
            verifierSigner: params.enclaveSigner,
            attestationQueue: params.attestationQueue,
            queueAuthority: params.queueAuthority,
            gcNode: params.gcOracle,
            permission: params.permission.publicKey,
        });
        return instruction;
    }
    async heartbeat(params, options) {
        const quote = params.quote ?? (await this.loadData());
        const queue = params.queue ??
            (await new index_js_1.AttestationQueueAccount(this.program, quote.attestationQueue).loadData());
        const quotes = queue.data.slice(0, queue.dataLen);
        let lastPubkey = this.publicKey;
        if (quotes.length !== 0 && quotes.length > queue.gcIdx) {
            lastPubkey = quotes[queue.gcIdx];
        }
        const heartbeatIxn = this.heartbeatInstruction({
            queueAuthority: queue.authority,
            permission: params.permission ??
                this.getPermissionAccount(quote.attestationQueue, queue.authority, this.publicKey),
            gcOracle: lastPubkey,
            attestationQueue: quote.attestationQueue,
            enclaveSigner: params.enclaveSigner.publicKey,
        });
        const heartbeatTxn = new TransactionObject_js_1.TransactionObject(this.program.walletPubkey, [heartbeatIxn], [params.enclaveSigner], options);
        const txnSignature = await this.program.signAndSend(heartbeatTxn, options);
        return txnSignature;
    }
    async rotateInstruction(payer, params, options) {
        const registryKey = (0, utils_js_1.parseRawBuffer)(params.registryKey, 64);
        const quoteData = await this.loadData();
        const authority = params.authority ? params.authority.publicKey : payer;
        if (!quoteData.authority.equals(authority)) {
            throw new errors.IncorrectAuthority(quoteData.authority, authority);
        }
        // yeet out of the wrapper so we can use the on-chain IDL
        const program = await this.program.attestationProgram;
        const rotateIxn = await program.methods
            .verifierQuoteRotate({ registryKey: [...registryKey].slice(0, 64) })
            .accounts({
            verifier: this.publicKey,
            authority: authority,
            enclaveSigner: params.enclaveSigner.publicKey,
            attestationQueue: quoteData.attestationQueue,
        })
            .instruction();
        // const rotateIxn = types.verifierQuoteRotate(
        //   this.program,
        //   {
        //     params: {
        //       registryKey: [...registryKey].slice(0, 64),
        //       secpPubkey: null,
        //     },
        //   },
        //   {
        //     verifier: this.publicKey,
        //     authority: authority,
        //     enclaveSigner: params.enclaveSigner.publicKey,
        //     attestationQueue: quoteData.attestationQueue,
        //   }
        // );
        const rotateTxn = new TransactionObject_js_1.TransactionObject(payer, [rotateIxn], params.authority
            ? [params.authority, params.enclaveSigner]
            : [params.enclaveSigner], options);
        return rotateTxn;
    }
    async rotate(params, options) {
        return await this.rotateInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async verifyInstruction(payer, params, options) {
        const verifierState = await this.loadData();
        const signers = [];
        if (params.enclaveSigner) {
            if (!params.enclaveSigner.publicKey.equals(verifierState.enclave.enclaveSigner)) {
                throw new Error(`SignerMismatch, expected ${verifierState.enclave.enclaveSigner}, received ${params.enclaveSigner.publicKey}`);
            }
            signers.push(params.enclaveSigner);
        }
        const attestationQueueAccount = new index_js_1.AttestationQueueAccount(this.program, verifierState.attestationQueue);
        const attestationQueue = await attestationQueueAccount.loadData();
        const verifierIdx = attestationQueue.data
            .slice(0, attestationQueue.dataLen)
            .findIndex((pubkey) => pubkey.equals(this.publicKey));
        if (verifierIdx === -1) {
            throw new Error(`Verifier not found on the attestation queue`);
        }
        const instruction = types.verifierQuoteVerify(this.program, {
            params: {
                timestamp: params.timestamp,
                mrEnclave: Array.from((0, common_1.parseRawMrEnclave)(params.mrEnclave)),
                idx: verifierIdx,
            },
        }, {
            quote: params.quote.publicKey,
            enclaveSigner: verifierState.enclave.enclaveSigner,
            verifier: this.publicKey,
            attestationQueue: verifierState.attestationQueue,
        });
        return new TransactionObject_js_1.TransactionObject(payer, [instruction], signers, options);
    }
    async verify(params, options) {
        return await this.verifyInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
}
exports.VerifierAccount = VerifierAccount;
