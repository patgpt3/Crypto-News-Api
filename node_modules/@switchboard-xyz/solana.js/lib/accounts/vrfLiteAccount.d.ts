import * as types from "../generated/oracle-program/index.js";
import type { SwitchboardProgram } from "../SwitchboardProgram.js";
import type { TransactionObjectOptions } from "../TransactionObject.js";
import { TransactionObject } from "../TransactionObject.js";
import type { OnAccountChangeCallback } from "./account.js";
import { Account } from "./account.js";
import { PermissionAccount } from "./permissionAccount.js";
import { QueueAccount } from "./queueAccount.js";
import type { Callback, VrfResult } from "./vrfAccount.js";
import type { Commitment, ParsedTransactionWithMeta, PublicKey, TransactionSignature } from "@solana/web3.js";
import { Keypair } from "@solana/web3.js";
import { BN } from "@switchboard-xyz/common";
export interface VrfLiteInitParams {
    callback?: Callback;
    expiration?: number;
    keypair?: Keypair;
    authority?: PublicKey;
}
export type VrfLiteDepositParams = {
    tokenWallet?: PublicKey;
    tokenAuthority?: Keypair;
    amount: number;
};
export interface VrfLiteProveAndVerifyParams {
    vrfLite: types.VrfLiteAccountData;
    counter?: BN;
    proof: string;
    oraclePubkey: PublicKey;
    oracleTokenWallet: PublicKey;
    oracleAuthority: PublicKey;
}
export interface VrfLiteCloseParams {
    destination?: PublicKey;
    authority?: Keypair;
    queueAccount?: QueueAccount;
    queueAuthority?: PublicKey;
}
export declare class VrfLiteAccount extends Account<types.VrfLiteAccountData> {
    /**
     * Invoke a callback each time a VrfAccount's data has changed on-chain.
     * @param callback - the callback invoked when the vrf state changes
     * @param commitment - optional, the desired transaction finality. defaults to 'confirmed'
     * @returns the websocket subscription id
     */
    onChange(callback: OnAccountChangeCallback<types.VrfLiteAccountData>, commitment?: Commitment): number;
    loadData(): Promise<types.VrfLiteAccountData>;
    static createInstruction(program: SwitchboardProgram, payer: PublicKey, params: VrfLiteInitParams & {
        queueAccount: QueueAccount;
    }): Promise<[VrfLiteAccount, TransactionObject]>;
    static create(program: SwitchboardProgram, params: VrfLiteInitParams & {
        queueAccount: QueueAccount;
    }): Promise<[VrfLiteAccount, TransactionSignature]>;
    depositInstructions(payer: PublicKey, params: VrfLiteDepositParams): Promise<TransactionObject>;
    deposit(params: VrfLiteDepositParams): Promise<TransactionSignature>;
    fetchBalance(escrow?: PublicKey): Promise<number>;
    fetchBalanceBN(escrow?: PublicKey): Promise<BN>;
    proveAndVerifyInstructions(params: VrfLiteProveAndVerifyParams, options?: TransactionObjectOptions, numTxns?: number): Array<TransactionObject>;
    proveAndVerify(params: Partial<VrfLiteProveAndVerifyParams> & {
        skipPreflight?: boolean;
    }, options?: TransactionObjectOptions, numTxns?: number): Promise<Array<TransactionSignature>>;
    awaitRandomness(params: {
        requestSlot: BN;
    }, timeout?: number): Promise<types.VrfLiteAccountData>;
    closeAccountInstruction(payer: PublicKey, params?: VrfLiteCloseParams): Promise<TransactionObject>;
    closeAccount(params?: VrfLiteCloseParams): Promise<TransactionSignature>;
    getPermissionAccount(queuePubkey: PublicKey, queueAuthority: PublicKey): [PermissionAccount, number];
    getEscrow(): PublicKey;
    /**
     * Await for the next vrf result
     *
     * @param roundId - optional, the id associated with the VRF round to watch. If not provided the current round Id will be used.
     * @param timeout - the number of milliseconds to wait for the round to close
     *
     * @throws {string} when the timeout interval is exceeded or when the latestConfirmedRound.roundOpenSlot exceeds the target roundOpenSlot
     */
    nextResult(roundId?: BN, timeout?: number): Promise<VrfResult>;
    /** Return parsed transactions for a VRF request */
    getCallbackTransactions(requestSlot?: BN, txnLimit?: number): Promise<Array<ParsedTransactionWithMeta>>;
}
//# sourceMappingURL=vrfLiteAccount.d.ts.map