"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionAccount = void 0;
const account_js_1 = require("../accounts/account.cjs");
const errors = __importStar(require("../errors.cjs"));
const types = __importStar(require("../generated/attestation-program/index.cjs"));
const SwitchboardProgram_js_1 = require("../SwitchboardProgram.cjs");
const TransactionObject_js_1 = require("../TransactionObject.cjs");
const utils_js_1 = require("../utils.cjs");
const index_js_1 = require("./index.cjs");
const anchor = __importStar(require("@coral-xyz/anchor"));
const spl = __importStar(require("@solana/spl-token"));
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const common_1 = require("@switchboard-xyz/common");
const assert_1 = __importDefault(require("assert"));
const addressLookupProgram = new web3_js_1.PublicKey("AddressLookupTab1e1111111111111111111111111");
/**
 * Account type representing a Switchboard Function.
 *
 * Data: {@linkcode types.FunctionAccountData}
 */
class FunctionAccount extends account_js_1.Account {
    static accountName = "FunctionAccountData";
    _wallet = undefined;
    /**
     *  Returns the functions's name buffer in a stringified format.
     */
    static getName = (functionState) => (0, common_1.toUtf8)(functionState.name);
    /**
     *  Returns the functions's metadata buffer in a stringified format.
     */
    static getMetadata = (functionState) => (0, common_1.toUtf8)(functionState.metadata);
    get wallet() {
        if (!this._wallet) {
            this._wallet = this.loadData().then((fnState) => {
                return new index_js_1.SwitchboardWallet(this.program, fnState.escrowWallet);
            });
        }
        return this._wallet;
    }
    set wallet(_wallet) {
        this._wallet = _wallet;
    }
    static fromSeed(program, creatorSeed, recentSlot) {
        if (creatorSeed.length > 32) {
            throw new Error("Creator seed must be 32 bytes or less");
        }
        const functionPubkey = anchor.web3.PublicKey.findProgramAddressSync([
            Buffer.from("FunctionAccountData"),
            creatorSeed.length < 32 ? (0, utils_js_1.parseRawBuffer)(creatorSeed, 32) : creatorSeed,
            recentSlot.toBuffer("le", 8),
        ], program.attestationProgramId)[0];
        return new FunctionAccount(program, functionPubkey);
    }
    async getBalance() {
        const wallet = await this.wallet;
        const balance = await wallet.getBalance();
        return balance;
    }
    async getBalanceBN() {
        const wallet = await this.wallet;
        const balance = await wallet.getBalanceBN();
        return balance;
    }
    /**
     *  Retrieve and decode the {@linkcode types.FunctionAccountData} stored in this account.
     */
    async loadData() {
        const data = await types.FunctionAccountData.fetch(this.program, this.publicKey);
        if (!data) {
            throw new errors.AccountNotFoundError("Function", this.publicKey);
        }
        this._wallet = Promise.resolve(new index_js_1.SwitchboardWallet(this.program, data.escrowWallet));
        return data;
    }
    /**
     *  Decode the {@linkcode types.FunctionAccountData} stored in this account.
     */
    static async decode(program, accountInfo) {
        if (!accountInfo.owner.equals(program.attestationProgramId)) {
            throw new errors.IncorrectOwner(program.attestationProgramId, accountInfo.owner);
        }
        const data = types.FunctionAccountData.decode(accountInfo.data);
        if (!data) {
            throw new errors.AccountNotFoundError("Function", web3_js_1.PublicKey.default);
        }
        (0, assert_1.default)(data.creatorSeed.length === 32);
        const functionAccount = FunctionAccount.fromSeed(program, new Uint8Array(data.creatorSeed), data.createdAtSlot);
        functionAccount._wallet = Promise.resolve(new index_js_1.SwitchboardWallet(program, data.escrowWallet));
        return [functionAccount, data];
    }
    /**
     *  Load an existing {@linkcode FunctionAccount} with its current on-chain state
     */
    static async load(program, address) {
        const functionAccount = new FunctionAccount(program, address);
        const state = await functionAccount.loadData();
        return [functionAccount, state];
    }
    static async createInstruction(program, payer, params, wallet, options) {
        const authorityPubkey = params.authority ?? payer;
        const attestationQueueAccount = params.attestationQueue;
        const recentSlot = params.recentSlot
            ? new common_1.BN(params.recentSlot)
            : new common_1.BN(await program.connection.getSlot({
                commitment: "finalized",
            }));
        const creatorSeed = params.creatorSeed
            ? (0, utils_js_1.parseRawBuffer)(params.creatorSeed, 32)
            : payer.toBytes();
        (0, assert_1.default)(creatorSeed.length === 32);
        const functionAccount = FunctionAccount.fromSeed(program, creatorSeed, recentSlot);
        const [addressLookupTable] = web3_js_1.PublicKey.findProgramAddressSync([functionAccount.publicKey.toBuffer(), recentSlot.toBuffer("le", 8)], addressLookupProgram);
        let escrowWallet;
        let escrowWalletAuthority;
        if (wallet) {
            escrowWallet = wallet;
            escrowWalletAuthority = (await escrowWallet.loadData()).authority;
            if (!escrowWalletAuthority.equals(payer) &&
                !escrowWalletAuthority.equals(authorityPubkey)) {
                throw new errors.IncorrectAuthority(escrowWalletAuthority, authorityPubkey);
            }
        }
        else {
            escrowWallet = index_js_1.SwitchboardWallet.fromSeed(program, attestationQueueAccount.publicKey, authorityPubkey, functionAccount.publicKey.toBytes());
            escrowWalletAuthority = authorityPubkey;
        }
        const instruction = types.functionInit(program, {
            params: {
                // PDA Config
                recentSlot: recentSlot,
                creatorSeed: Array.from(creatorSeed),
                // Metadata Config
                name: new Uint8Array(Buffer.from(params.name ?? "", "utf8")),
                metadata: new Uint8Array(Buffer.from(params.metadata ?? "", "utf8")),
                // Container Config
                container: new Uint8Array(Buffer.from(params.container, "utf8")),
                containerRegistry: new Uint8Array(Buffer.from(params.containerRegistry ?? "dockerhub", "utf8")),
                version: new Uint8Array(Buffer.from(params.version ?? "latest", "utf8")),
                mrEnclave: Array.from(params.mrEnclave ? (0, common_1.parseRawMrEnclave)(params.mrEnclave) : []),
                // Requests Config
                requestsDisabled: params.requestsDisabled ?? false,
                requestsRequireAuthorization: params.requestsRequireAuthorization ?? false,
                requestsDevFee: (0, utils_js_1.numToBN)(params.requestsFee),
                // Routines Config
                routinesDisabled: params.routinesDisabled ?? false,
                routinesDevFee: (0, utils_js_1.numToBN)(params.routinesFee),
                routinesRequireAuthorization: false,
            },
        }, {
            function: functionAccount.publicKey,
            addressLookupTable: addressLookupTable,
            authority: authorityPubkey,
            attestationQueue: attestationQueueAccount.publicKey,
            payer,
            escrowWallet: escrowWallet.publicKey,
            escrowWalletAuthority: escrowWalletAuthority,
            escrowTokenWallet: escrowWallet.tokenWallet,
            mint: program.mint.address,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            associatedTokenProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: web3_js_1.SystemProgram.programId,
            addressLookupProgram: addressLookupProgram,
        });
        functionAccount.wallet = Promise.resolve(escrowWallet);
        if (params.enableServices) {
            // TODO: account for case where authority keypair was not provided and authority != payer. We'll need to set authority to payer then set authority as last ixn
            const setConfigIxn = types.functionSetConfig(program, {
                params: {
                    name: null,
                    metadata: null,
                    container: null,
                    containerRegistry: null,
                    version: null,
                    mrEnclaves: null,
                    requestsDisabled: null,
                    requestsRequireAuthorization: null,
                    requestsDevFee: null,
                    routinesDisabled: null,
                    lockRoutinesDisabled: null,
                    routinesRequireAuthorization: null,
                    routinesDevFee: null,
                    // Set services config
                    servicesDisabled: false,
                    lockServicesDisabled: params.lockServicesDisabled ?? false,
                    servicesRequireAuthorization: params.servicesRequireAuthorization ?? false,
                    servicesDevFee: params.servicesFee
                        ? program.mint.toTokenAmountBN(params.servicesFee)
                        : null,
                    servicesSignerRotationInterval: params.servicesSignerRotationInterval
                        ? new common_1.BN(params.servicesSignerRotationInterval)
                        : null,
                },
            }, {
                function: functionAccount.publicKey,
                authority: authorityPubkey,
            });
            return [
                functionAccount,
                new TransactionObject_js_1.TransactionObject(payer, [instruction, setConfigIxn], [], {
                    ...options,
                    computeUnitLimit: 350000,
                }),
            ];
        }
        return [
            functionAccount,
            new TransactionObject_js_1.TransactionObject(payer, [instruction], [], {
                ...options,
                computeUnitLimit: 350000,
            }),
        ];
    }
    static async create(program, params, wallet, options) {
        const [account, txnObject] = await this.createInstruction(program, program.walletPubkey, params, wallet, options);
        const txSignature = await program.signAndSend(txnObject, options);
        return [account, txSignature];
    }
    async createRequestInstruction(payer, params, options) {
        // const functionState = await this.loadData();
        const [requestAccount, txnObject] = await index_js_1.FunctionRequestAccount.createInstruction(this.program, payer, {
            ...params,
            functionAccount: this,
        }, options);
        return [requestAccount, txnObject];
    }
    async createRequest(params, options) {
        const [account, txnObject] = await this.createRequestInstruction(this.program.walletPubkey, params, options);
        const txSignature = await this.program.signAndSend(txnObject, options);
        return [account, txSignature];
    }
    async createRoutineInstruction(payer, params, wallet, options) {
        const [routineAccount, txnObject] = await index_js_1.FunctionRoutineAccount.createInstruction(this.program, payer, {
            ...params,
            functionAccount: this,
        }, wallet, options);
        return [routineAccount, txnObject];
    }
    async createRoutine(params, wallet, options) {
        const [account, txnObject] = await this.createRoutineInstruction(this.program.walletPubkey, params, wallet, options);
        const txSignature = await this.program.signAndSend(txnObject, options);
        return [account, txSignature];
    }
    async createServiceInstruction(payer, params, wallet, options) {
        const [serviceAccount, txnObject] = await index_js_1.FunctionServiceAccount.createInstruction(this.program, payer, {
            ...params,
            functionAccount: this,
        }, wallet, options);
        return [serviceAccount, txnObject];
    }
    async createService(params, wallet, options) {
        const [account, txnObject] = await this.createServiceInstruction(this.program.walletPubkey, params, wallet, options);
        const txSignature = await this.program.signAndSend(txnObject, options);
        return [account, txSignature];
    }
    async setConfigInstruction(payer, params, options) {
        const functionState = await this.loadData();
        if (params.authority) {
            if (!params.authority.publicKey.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, params.authority.publicKey);
            }
        }
        else {
            if (!payer.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, payer);
            }
        }
        const toOptionalBytes = (param) => {
            return param ? new Uint8Array(Buffer.from(param, "utf8")) : null;
        };
        const setConfigIxn = types.functionSetConfig(this.program, {
            params: {
                // Metadata Config
                name: toOptionalBytes(params.name),
                metadata: toOptionalBytes(params.metadata),
                // Container Config
                container: toOptionalBytes(params.container),
                containerRegistry: toOptionalBytes(params.containerRegistry),
                version: toOptionalBytes(params.version),
                mrEnclaves: params.mrEnclaves
                    ? params.mrEnclaves.map((mrEnclave) => Array.from((0, utils_js_1.parseRawBuffer)(mrEnclave)))
                    : null,
                // Requests Config
                requestsDisabled: params.requestsDisabled ?? null,
                requestsRequireAuthorization: params.requestsRequireAuthorization ?? null,
                requestsDevFee: params.requestsFee
                    ? new common_1.BN(params.requestsFee)
                    : null,
                // Routines Config
                routinesDisabled: params.routinesDisabled ?? null,
                lockRoutinesDisabled: params.lockRoutinesDisabled ?? null,
                routinesRequireAuthorization: params.routinesRequireAuthorization ?? null,
                routinesDevFee: params.routinesFee
                    ? new common_1.BN(params.routinesFee)
                    : null,
                // Services Config
                servicesDisabled: params.servicesDisabled ?? null,
                lockServicesDisabled: params.lockServicesDisabled ?? null,
                servicesRequireAuthorization: params.servicesRequireAuthorization ?? null,
                servicesDevFee: params.servicesFee
                    ? new common_1.BN(params.servicesFee)
                    : null,
                servicesSignerRotationInterval: params.servicesSignerRotationInterval
                    ? new common_1.BN(params.servicesSignerRotationInterval)
                    : null,
            },
        }, {
            function: this.publicKey,
            authority: functionState.authority,
        });
        return new TransactionObject_js_1.TransactionObject(payer, [setConfigIxn], params?.authority ? [params.authority] : [], options);
    }
    async setConfig(params, options) {
        return await this.setConfigInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    static hasMrEnclave(mrEnclaves, targetMrEnclave) {
        return (0, utils_js_1.containsMrEnclave)(mrEnclaves, targetMrEnclave);
    }
    async addMrEnclaveInstruction(payer, mrEnclave, params, options) {
        const force = params?.force ?? false;
        const functionState = params?.functionState ?? (await this.loadData());
        if (FunctionAccount.hasMrEnclave(functionState.mrEnclaves, mrEnclave)) {
            throw new errors.FunctionMrEnclaveAlreadySet();
        }
        const filteredMrEnclaves = functionState.mrEnclaves.filter((arr) => !arr.every((num) => num === 0));
        if (filteredMrEnclaves.length >= 32 && !force) {
            throw new errors.FunctionMrEnclavesFull();
        }
        const newMrEnclaves = [
            ...(filteredMrEnclaves.length >= 32
                ? filteredMrEnclaves.slice(filteredMrEnclaves.length - 32 + 1)
                : filteredMrEnclaves),
            Array.from(mrEnclave),
        ];
        if (params?.authority) {
            if (!params.authority.publicKey.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, params.authority.publicKey);
            }
        }
        else {
            if (!payer.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, payer);
            }
        }
        let version = null;
        if (params?.newVersion) {
            version = new Uint8Array(Buffer.from(params.newVersion, "utf8"));
        }
        const toTxn = (mrEnclaves) => {
            try {
                const setConfigIxn = types.functionSetConfig(this.program, {
                    params: {
                        // Metadata Config
                        name: null,
                        metadata: null,
                        // Container Config
                        container: null,
                        containerRegistry: null,
                        version: version,
                        mrEnclaves: mrEnclaves,
                        // Requests Config
                        requestsDisabled: null,
                        requestsRequireAuthorization: null,
                        requestsDevFee: null,
                        // Routines Config
                        routinesDisabled: null,
                        lockRoutinesDisabled: null,
                        routinesDevFee: null,
                        routinesRequireAuthorization: null,
                        // Services Config
                        servicesDisabled: null,
                        lockServicesDisabled: null,
                        servicesDevFee: null,
                        servicesRequireAuthorization: null,
                        servicesSignerRotationInterval: null,
                    },
                }, {
                    function: this.publicKey,
                    authority: functionState.authority,
                });
                return new TransactionObject_js_1.TransactionObject(payer, [setConfigIxn], params?.authority ? [params.authority] : [], options);
            }
            catch (error) {
                if (error instanceof RangeError) {
                    throw new errors.TransactionOverflowError(`Try removing some of the MrEnclaves from the function config first or provide the force flag.`);
                }
                throw error;
            }
        };
        // If we dont provide the force flag, then skip removing any old MrEnclaves.
        if (!force) {
            return toTxn(newMrEnclaves);
        }
        // Attempt to remove up to 5 of the oldest MrEnclaves to get the ixn to fit.
        let retryCount = 5;
        let mrEnclaves = [...newMrEnclaves];
        while (retryCount > 0) {
            try {
                return toTxn(mrEnclaves);
            }
            catch (error) {
                if (retryCount === 0 ||
                    !(error instanceof errors.TransactionOverflowError)) {
                    throw error;
                }
                mrEnclaves = mrEnclaves.slice(1);
                --retryCount;
            }
        }
        throw new errors.TransactionOverflowError(`Try removing some of the MrEnclaves from the function config first or provide the force flag.`);
    }
    async addMrEnclave(mrEnclave, params, options) {
        return await this.addMrEnclaveInstruction(this.program.walletPubkey, mrEnclave, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    /**
     * Try to add a MrEnclave to the function config, if it is not already present. Returns undefined
     * if MrEnclave is already in the config.
     */
    async tryAddMrEnclave(mrEnclave, params, options) {
        const functionState = params?.functionState ?? (await this.loadData());
        if (FunctionAccount.hasMrEnclave(functionState.mrEnclaves, mrEnclave)) {
            return undefined;
        }
        return await this.addMrEnclaveInstruction(this.program.walletPubkey, mrEnclave, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async setEscrowInstruction(payer, params, options) {
        const signers = [];
        if (params.authority) {
            signers.push(params.authority);
        }
        if (params.newEscrowAuthority) {
            signers.push(params.newEscrowAuthority);
        }
        const functionState = await this.loadData();
        const currentWallet = await this.wallet;
        const currentWalletState = await currentWallet.loadData();
        const newWallet = params.newEscrow;
        const newWalletState = await newWallet.loadData();
        const functionSetEscrowIxn = types.functionSetEscrow(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            attestationQueue: functionState.attestationQueue,
            escrowWallet: currentWallet.publicKey,
            escrowAuthority: currentWalletState.authority,
            newEscrow: newWallet.publicKey,
            newEscrowAuthority: newWalletState.authority,
            newEscrowTokenWallet: newWallet.tokenWallet,
        });
        return new TransactionObject_js_1.TransactionObject(payer, [functionSetEscrowIxn], signers, options);
    }
    async setEscrow(params, options) {
        return await this.setEscrowInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async setAuthorityInstruction(payer, params, options) {
        const signers = [];
        if (params.authority) {
            signers.push(params.authority);
        }
        if (params.walletAuthority) {
            signers.push(params.walletAuthority);
        }
        const functionState = await this.loadData();
        const wallet = await this.wallet;
        const walletState = await wallet.loadData();
        const functionSetAuthorityIxn = types.functionSetAuthority(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            attestationQueue: functionState.attestationQueue,
            escrowWallet: wallet.publicKey,
            escrowAuthority: walletState.authority,
            newAuthority: params.newAuthority,
            walletAuthority: params.walletAuthority
                ? params.walletAuthority.publicKey
                : SwitchboardProgram_js_1.SB_ATTESTATION_PID,
        });
        return new TransactionObject_js_1.TransactionObject(payer, [(0, utils_js_1.handleOptionalPubkeys)(functionSetAuthorityIxn)], signers, options);
    }
    async setAuthority(params, options) {
        return await this.setAuthorityInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async resetEscrowInstruction(payer, authority, options) {
        const functionState = await this.loadData();
        const defaultWallet = index_js_1.SwitchboardWallet.fromSeed(this.program, functionState.attestationQueue, functionState.authority, this.publicKey.toBytes());
        const ixn = types.functionResetEscrow(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            attestationQueue: functionState.attestationQueue,
            mint: this.program.mint.address,
            escrowWallet: functionState.escrowWallet,
            defaultWallet: defaultWallet.publicKey,
            tokenWallet: defaultWallet.tokenWallet,
            payer: payer,
            tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,
            associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,
            systemProgram: anchor.web3.SystemProgram.programId,
        });
        const txn = new TransactionObject_js_1.TransactionObject(payer, [ixn], authority ? [authority] : [], options);
        return txn;
    }
    async resetEscrow(authority, options) {
        return await this.resetEscrowInstruction(this.program.walletPubkey, authority, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async fundInstruction(payer, params, options) {
        const wallet = await this.wallet;
        const txn = await wallet.fundInstruction(payer, { ...params, resources: [this.publicKey] }, options);
        return txn;
    }
    async fund(params, options) {
        return await this.fundInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async wrapInstruction(payer, amount, options) {
        const wallet = await this.wallet;
        const txn = await wallet.wrapInstruction(payer, amount, options);
        return txn;
    }
    async wrap(amount, options) {
        return await this.wrapInstruction(this.program.walletPubkey, amount, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async withdrawInstruction(payer, amount, destinationWallet, options) {
        const wallet = await this.wallet;
        const txn = await wallet.withdrawInstruction(payer, amount, destinationWallet, options);
        return txn;
    }
    async withdraw(amount, destinationWallet, options) {
        return await this.withdrawInstruction(this.program.walletPubkey, amount, destinationWallet, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async closeAccountInstruction(payer, params, options) {
        const signers = [];
        if (params.authority) {
            signers.push(params.authority);
        }
        const functionState = await this.loadData();
        const wallet = await this.wallet;
        const functionCloseIxn = types.functionClose(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            addressLookupProgram: addressLookupProgram,
            addressLookupTable: functionState.addressLookupTable,
            escrowWallet: wallet.publicKey,
            solDest: payer,
            escrowDest: this.program.mint.getAssociatedAddress(payer),
            tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,
            systemProgram: anchor.web3.SystemProgram.programId,
        });
        return new TransactionObject_js_1.TransactionObject(payer, [functionCloseIxn], signers, options);
    }
    async closeAccount(params, options) {
        return await this.closeAccountInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    verifyInstructionSync(params) {
        const wallet = new index_js_1.SwitchboardWallet(this.program, params.escrowWallet);
        const escrowTokenWallet = wallet.tokenWallet;
        return types.functionVerify(this.program, {
            params: {
                observedTime: params.observedTime,
                nextAllowedTimestamp: params.nextAllowedTimestamp,
                errorCode: params.isFailure ? 1 : 0,
                mrEnclave: Array.from(params.mrEnclave),
            },
        }, {
            // fn accounts
            function: this.publicKey,
            functionEnclaveSigner: params.functionEnclaveSigner,
            // verifier accounts
            verifier: params.quoteVerifier,
            verifierSigner: params.quoteVerifierEnclaveSigner,
            verifierPermission: index_js_1.AttestationPermissionAccount.fromSeed(this.program, params.attestationQueueAuthority, params.attestationQueue, params.quoteVerifier).publicKey,
            // token accounts
            escrowWallet: params.escrowWallet,
            escrowTokenWallet: escrowTokenWallet,
            receiver: params.receiver,
            // others
            attestationQueue: params.attestationQueue,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
        });
    }
    async verifyInstruction(params) {
        const functionState = params.fnState ?? (await this.loadData());
        const wallet = await this.wallet;
        let attestationQueueAuthority = params.attestationQueueAuthority;
        if (!attestationQueueAuthority) {
            const attestationQueueAccount = new index_js_1.AttestationQueueAccount(this.program, functionState.attestationQueue);
            attestationQueueAuthority = (await attestationQueueAccount.loadData())
                .authority;
        }
        const quoteVerifier = await params.verifier.loadData();
        return this.verifyInstructionSync({
            observedTime: params.observedTime,
            nextAllowedTimestamp: params.nextAllowedTimestamp,
            isFailure: params.isFailure,
            mrEnclave: params.mrEnclave,
            escrowWallet: wallet.publicKey,
            functionEnclaveSigner: params.functionEnclaveSigner,
            attestationQueue: functionState.attestationQueue,
            attestationQueueAuthority: attestationQueueAuthority,
            quoteVerifier: params.verifier.publicKey,
            quoteVerifierEnclaveSigner: quoteVerifier.enclave.enclaveSigner,
            receiver: params.receiver,
        });
    }
    async verifyTransaction(params) {
        const fnState = await this.loadData();
        const ixn = await this.verifyInstruction({ ...params, fnState });
        const lookupTable = await this.program.connection
            .getAddressLookupTable(fnState.addressLookupTable)
            .then((res) => res.value);
        const messageV0 = new anchor.web3.TransactionMessage({
            payerKey: this.program.walletPubkey,
            recentBlockhash: (await this.program.connection.getLatestBlockhash())
                .blockhash,
            instructions: [ixn], // note this is an array of instructions
        }).compileToV0Message([lookupTable]);
        const transactionV0 = new anchor.web3.VersionedTransaction(messageV0);
        return transactionV0;
    }
    async verify(params, options) {
        const transactionV0 = await this.verifyTransaction({
            ...params,
            verifierEnclaveSigner: params.verifierEnclaveSigner.publicKey,
            functionEnclaveSigner: params.functionEnclaveSigner.publicKey,
        });
        transactionV0.sign([params.verifierEnclaveSigner]);
        transactionV0.sign([params.functionEnclaveSigner]);
        transactionV0.sign([this.program.wallet.payer]);
        const txnSignature = await this.program.connection.sendEncodedTransaction(Buffer.from(transactionV0.serialize()).toString("base64"), options);
        return txnSignature;
    }
    async triggerInstruction(payer, params, options) {
        const functionState = await this.loadData();
        // verify authority is correct
        if (params && params?.authority) {
            if (!params.authority.publicKey.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, params.authority.publicKey);
            }
        }
        else {
            if (!payer.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, payer);
            }
        }
        const functionTrigger = types.functionTrigger(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            attestationQueue: functionState.attestationQueue,
        });
        return new TransactionObject_js_1.TransactionObject(payer, [functionTrigger], params?.authority ? [params.authority] : [], options);
    }
    async trigger(params, options) {
        return await this.triggerInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    static decodeAddressLookup(lookupTable) {
        const addresses = lookupTable.state.addresses;
        if (addresses.length < 16) {
            throw new Error(`Failed to decode address lookup table`);
        }
        const systemProgram = addresses[0];
        if (!systemProgram.equals(anchor.web3.SystemProgram.programId)) {
            throw new Error("AddressLookupMismatch");
        }
        const tokenProgram = addresses[1];
        if (!tokenProgram.equals(anchor.utils.token.TOKEN_PROGRAM_ID)) {
            throw new Error("AddressLookupMismatch");
        }
        const assocatedTokenProgram = addresses[2];
        if (!assocatedTokenProgram.equals(anchor.utils.token.ASSOCIATED_PROGRAM_ID)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarRent = addresses[3];
        if (!sysVarRent.equals(anchor.web3.SYSVAR_RENT_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarRecentBlockhashes = addresses[4];
        if (!sysVarRecentBlockhashes.equals(anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarInstructions = addresses[5];
        if (!sysVarInstructions.equals(anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarSlotHashes = addresses[6];
        if (!sysVarSlotHashes.equals(anchor.web3.SYSVAR_SLOT_HASHES_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarSlotHistory = addresses[7];
        if (!sysVarSlotHistory.equals(anchor.web3.SYSVAR_SLOT_HISTORY_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const switchboardProgram = addresses[8];
        if (!switchboardProgram.equals(SwitchboardProgram_js_1.SB_V2_PID)) {
            throw new Error("AddressLookupMismatch");
        }
        const attestationProgram = addresses[9];
        if (!attestationProgram.equals(SwitchboardProgram_js_1.SB_ATTESTATION_PID)) {
            throw new Error("AddressLookupMismatch");
        }
        // switchboard accounts, not worth the network calls
        const attestationQueuePubkey = addresses[10];
        const functionPubkey = addresses[11];
        const functionAuthorityPubkey = addresses[12];
        const mintPubkey = addresses[13];
        const walletPubkey = addresses[14];
        const escrowPubkey = addresses[15];
        return {
            systemProgram,
            tokenProgram,
            assocatedTokenProgram,
            sysVarRent,
            sysVarRecentBlockhashes,
            sysVarInstructions,
            sysVarSlotHashes,
            sysVarSlotHistory,
            switchboardProgram,
            attestationProgram,
            attestationQueuePubkey,
            functionPubkey,
            functionAuthorityPubkey,
            mintPubkey,
            walletPubkey,
            escrowPubkey, // 16
        };
    }
    static getVerificationStatus(state) {
        switch (state.enclave.verificationStatus) {
            case types.VerificationStatus.None.discriminator:
                return new types.VerificationStatus.None();
            case types.VerificationStatus.VerificationPending.discriminator:
                return new types.VerificationStatus.VerificationPending();
            case types.VerificationStatus.VerificationFailure.discriminator:
                return new types.VerificationStatus.VerificationFailure();
            case types.VerificationStatus.VerificationSuccess.discriminator:
                return new types.VerificationStatus.VerificationSuccess();
            case types.VerificationStatus.VerificationOverride.discriminator:
                return new types.VerificationStatus.VerificationOverride();
        }
        throw new Error(`Failed to get the verification status, expected [${types.VerificationStatus.None.discriminator}, ${types.VerificationStatus.VerificationPending.discriminator}, ${types.VerificationStatus.VerificationFailure.discriminator}, ${types.VerificationStatus.VerificationSuccess.discriminator}], or ${types.VerificationStatus.VerificationOverride.discriminator}], received ${state.enclave.verificationStatus}`);
    }
}
exports.FunctionAccount = FunctionAccount;
