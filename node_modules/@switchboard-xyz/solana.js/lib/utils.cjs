"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculatePriorityFee = exports.numToBN = exports.parseRawBuffer = exports.updateStaticFeed = exports.createStaticFeed = exports.loadKeypair = exports.handleOptionalPubkeys = exports.filterEmptyMrEnclaves = exports.containsMrEnclave = exports.combineMrEnclaveSets = void 0;
const index_js_1 = require("./accounts/index.cjs");
const TransactionObject_js_1 = require("./TransactionObject.cjs");
const web3_js_1 = require("@solana/web3.js");
const web3_js_2 = require("@solana/web3.js");
const common_1 = require("@switchboard-xyz/common");
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
var common_2 = require("@switchboard-xyz/common");
Object.defineProperty(exports, "combineMrEnclaveSets", { enumerable: true, get: function () { return common_2.combineMrEnclaveSets; } });
Object.defineProperty(exports, "containsMrEnclave", { enumerable: true, get: function () { return common_2.containsMrEnclave; } });
Object.defineProperty(exports, "filterEmptyMrEnclaves", { enumerable: true, get: function () { return common_2.filterEmptyMrEnclaves; } });
function handleOptionalPubkeys(ixn) {
    const programId = ixn.programId;
    const data = ixn.data;
    const keys = ixn.keys.map((meta) => {
        if (meta.pubkey.equals(programId)) {
            return {
                isSigner: false,
                isWritable: false,
                pubkey: programId,
            };
        }
        return meta;
    });
    return new web3_js_1.TransactionInstruction({
        programId,
        keys,
        data,
    });
}
exports.handleOptionalPubkeys = handleOptionalPubkeys;
function loadKeypair(keypairPath) {
    const fullPath = keypairPath.startsWith("/") || keypairPath.startsWith("C:")
        ? keypairPath
        : keypairPath.startsWith("~")
            ? os_1.default.homedir() + keypairPath.slice(1)
            : path_1.default.join(process.cwd(), keypairPath);
    if (!fs_1.default.existsSync(fullPath)) {
        const keypair = web3_js_2.Keypair.generate();
        const dir = path_1.default.dirname(fullPath);
        if (!fs_1.default.existsSync(dir)) {
            fs_1.default.mkdirSync(dir, { recursive: true });
        }
        fs_1.default.writeFileSync(fullPath, `[${keypair.secretKey}]`);
        return keypair;
    }
    return web3_js_2.Keypair.fromSecretKey(new Uint8Array(JSON.parse(fs_1.default.readFileSync(fullPath, "utf-8"))));
}
exports.loadKeypair = loadKeypair;
/**
 * Create a feed and wait for it to resolve to a static value
 * @param queueAccount - the oracle queue to create the feed on
 * @param params - the aggregator init params and the static value to resolve the feed to
 * @param timeout - the number of milliseconds to wait before timing out
 *
 * Basic usage example:
 *
 * ```ts
 * import { createStaticFeed, QueueAccount, AggregatorAccount } from "@switchboard-xyz/solana.js";
 *
 * let queueAccount: QueueAccount;
 * let staticFeedAccount: AggregatorAccount;
 *
 * [staticFeedAccount] = await createStaticFeed(queueAccount, {
 *    value: 10,
 * });
 * const staticFeedValue: Big = await staticFeedAccount.fetchLatestValue();
 * assert(staticFeedValue.toNumber() === 10, "StaticFeedValueMismatch");
 * ```
 */
async function createStaticFeed(queueAccount, params, timeout = 30000) {
    const [aggregatorAccount] = await queueAccount.createFeed({
        ...params,
        batchSize: params.batchSize ?? 1,
        minUpdateDelaySeconds: params.minUpdateDelaySeconds ?? 10,
        minRequiredOracleResults: params.minRequiredOracleResults ?? 1,
        minRequiredJobResults: params.minRequiredJobResults ?? 1,
        jobs: [
            {
                weight: 1,
                data: common_1.OracleJob.encodeDelimited(common_1.OracleJob.fromObject({
                    tasks: [
                        {
                            valueTask: {
                                value: params.value,
                            },
                        },
                    ],
                })).finish(),
            },
        ],
    });
    const [state] = await aggregatorAccount.openRoundAndAwaitResult(undefined, timeout);
    return [aggregatorAccount, state];
}
exports.createStaticFeed = createStaticFeed;
/**
 * Update an existing aggregator that resolves to a new static value, then await the new result
 * @param aggregatorAccount - the aggregator account to modify
 * @param value - the static value the feed will resolve to
 * @param timeout - the number of milliseconds to wait before timing out
 *
 * Basic usage example:
 *
 * ```ts
 * import { updateStaticFeed, AggregatorAccount } from "@switchboard-xyz/solana.js";
 *
 * let staticFeedAccount: AggregatorAccount;
 *
 * const staticFeedState = await updateStaticFeed(staticFeedAccount, 100);
 * staticFeedValue = AggregatorAccount.decodeLatestValue(staticFeedState);
 * assert(staticFeedValue.toNumber() === 100, "StaticFeedValueMismatch");
 * ```
 */
async function updateStaticFeed(aggregatorAccount, value, timeout = 30000) {
    const aggregator = await aggregatorAccount.loadData();
    const [jobAccount, jobInit] = index_js_1.JobAccount.createInstructions(aggregatorAccount.program, aggregatorAccount.program.walletPubkey, {
        keypair: web3_js_2.Keypair.generate(),
        data: common_1.OracleJob.encodeDelimited(common_1.OracleJob.create({
            tasks: [
                common_1.OracleJob.Task.create({
                    valueTask: common_1.OracleJob.ValueTask.create({
                        value,
                    }),
                }),
            ],
        })).finish(),
    });
    const oldJobKeys = aggregator.jobPubkeysData.filter((pubkey) => !pubkey.equals(web3_js_2.PublicKey.default));
    const oldJobs = oldJobKeys.map((pubkey, i) => [
        new index_js_1.JobAccount(aggregatorAccount.program, pubkey),
        i,
    ]);
    const removeJobTxns = oldJobs.map((job) => aggregatorAccount.removeJobInstruction(aggregatorAccount.program.walletPubkey, {
        job: job[0],
        jobIdx: job[1],
    }));
    const addJobTxn = aggregatorAccount.addJobInstruction(aggregatorAccount.program.walletPubkey, { job: jobAccount });
    const txns = TransactionObject_js_1.TransactionObject.pack([
        ...jobInit,
        ...removeJobTxns,
        addJobTxn,
    ]);
    await aggregatorAccount.program.signAndSendAll(txns);
    const [state] = await aggregatorAccount.openRoundAndAwaitResult(undefined, timeout);
    return state;
}
exports.updateStaticFeed = updateStaticFeed;
const bytesRegex = /^\[(\s)?[0-9]+((\s)?,(\s)?[0-9]+){31,}\]/g;
const hexRegex = /^(0x|0X)?[a-fA-F0-9]{64}/g;
const base64Regex = /^(?:[A-Za-z\d+\/]{4})*(?:[A-Za-z\d+\/]{3}=|[A-Za-z\d+\/]{2}==)?/g;
function parseRawBuffer(rawBuffer, size = 32) {
    let myUint8Array;
    if (typeof rawBuffer === "string") {
        if (bytesRegex.test(rawBuffer)) {
            // check if its a string of bytes '[1,2,3]'
            myUint8Array = new Uint8Array(JSON.parse(rawBuffer));
        }
        else if (hexRegex.test(rawBuffer)) {
            // check if its a hex string '0x1A'
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer.replaceAll(/0x|0X/g, ""), "hex"));
        }
        else if (base64Regex.test(rawBuffer)) {
            // check if its a base64 string
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer, "base64"));
        }
        else {
            // assume utf-8
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer, "utf-8"));
        }
    }
    else if (rawBuffer instanceof Buffer) {
        myUint8Array = new Uint8Array(rawBuffer);
    }
    else if (rawBuffer instanceof Uint8Array) {
        myUint8Array = rawBuffer;
    }
    else {
        // Assume input is number[]
        myUint8Array = new Uint8Array(rawBuffer);
    }
    // make sure its always 32 bytes
    return new Uint8Array(Array.from(myUint8Array).concat(Array(size).fill(0)).slice(0, size));
}
exports.parseRawBuffer = parseRawBuffer;
function numToBN(num, defaultVal = 0) {
    if (!num) {
        return new common_1.BN(defaultVal);
    }
    if (typeof num === "number") {
        return new common_1.BN(num);
    }
    return num;
}
exports.numToBN = numToBN;
function calculatePriorityFee(timestamp, roundOpenTimestamp, basePriorityFee, priorityFeeBump, priorityFeeBumpPeriod, maxPriorityFeeMultiplier) {
    if (priorityFeeBumpPeriod <= 0) {
        return basePriorityFee;
    }
    if (maxPriorityFeeMultiplier <= 0) {
        return basePriorityFee;
    }
    const staleness = Math.round(timestamp - roundOpenTimestamp);
    if (staleness <= 0) {
        return basePriorityFee;
    }
    const feeMultiplier = Math.floor(staleness / priorityFeeBumpPeriod) - 1;
    const multiplier = feeMultiplier > 0 ? Math.min(feeMultiplier, maxPriorityFeeMultiplier) : 0;
    return Math.floor(priorityFeeBump * multiplier + basePriorityFee);
}
exports.calculatePriorityFee = calculatePriorityFee;
