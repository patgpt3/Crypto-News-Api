"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionRunner = void 0;
const AttestationQueueAccountData_js_1 = require("../generated/attestation-program/accounts/AttestationQueueAccountData.cjs");
const FunctionAccountData_js_1 = require("../generated/attestation-program/accounts/FunctionAccountData.cjs");
const FunctionRequestAccountData_js_1 = require("../generated/attestation-program/accounts/FunctionRequestAccountData.cjs");
const VerifierAccountData_js_1 = require("../generated/attestation-program/accounts/VerifierAccountData.cjs");
const functionRequestVerify_js_1 = require("../generated/attestation-program/instructions/functionRequestVerify.cjs");
const functionVerify_js_1 = require("../generated/attestation-program/instructions/functionVerify.cjs");
const index_js_1 = require("../index.cjs");
const SwitchboardProgram_js_1 = require("../SwitchboardProgram.cjs");
const env_js_1 = require("./env.cjs");
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const common_1 = require("@switchboard-xyz/common");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const crypto_1 = __importDefault(require("crypto"));
const dotenv_1 = __importDefault(require("dotenv"));
const fs_1 = __importDefault(require("fs"));
dotenv_1.default.config();
function unixTimestamp() {
    return Math.floor(Date.now() / 1000);
}
class FunctionRunner {
    program;
    env;
    enclaveSigner = web3_js_1.Keypair.generate();
    start = unixTimestamp();
    constructor(program, env) {
        this.program = program;
        this.env = env;
    }
    isSimulation() {
        return this.env.isSimulation ?? false;
    }
    get signer() {
        return this.enclaveSigner.publicKey;
    }
    get connection() {
        return this.program.provider.connection;
    }
    // Required
    get payer() {
        return this.env.payer;
    }
    // Required
    get verifier() {
        return this.env.verifier;
    }
    // Required
    get rewardReceiver() {
        return this.env.rewardReceiver;
    }
    get provider() {
        return this.program.provider;
    }
    // Required
    get functionKey() {
        return this.env.functionKey;
    }
    get functionData() {
        // return this.env.functionData;
        if (!this.env.functionData) {
            this.env.functionData = FunctionAccountData_js_1.FunctionAccountData.fetch(this.program, this.env.functionKey)
                .then((data) => {
                if (!data) {
                    throw new Error("Function data not found!");
                }
                return data;
            })
                .catch((err) => {
                this.env.functionData = undefined;
                throw err;
            });
        }
        return this.env.functionData;
    }
    get functionRequestKey() {
        if (!this.env.functionRequestKey) {
            throw new Error("Function request key not found!");
        }
        return this.env.functionRequestKey;
    }
    get functionRequestData() {
        if (!this.env.functionRequestData) {
            this.env.functionRequestData = FunctionRequestAccountData_js_1.FunctionRequestAccountData.fetch(this.program, this.functionRequestKey)
                .then((data) => {
                if (!data) {
                    throw new Error("Function request data not found!");
                }
                return data;
            })
                .catch((err) => {
                this.env.functionRequestData = undefined;
                throw err;
            });
        }
        return this.env.functionRequestData;
    }
    // public get verifierPermission(): PublicKey {
    //   return PublicKey.findProgramAddressSync(
    //     [
    //       Buffer.from("PermissionAccountData"),
    //       this.env.queueAuthority.toBytes(),
    //       this.env.functionData.attestationQueue.toBytes(),
    //       this.env.verifier.toBytes(),
    //     ],
    //     this.program.attestationProgramId
    //   )[0];
    // }
    static create(rpcEndpoint, commitment = "confirmed") {
        const env = (0, env_js_1.getEnv)();
        if (env.IS_SIMULATION) {
            console.debug(`IS_SIMULATION: true`);
        }
        const cluster = env.CLUSTER;
        const connection = new web3_js_1.Connection(rpcEndpoint ?? cluster === "localnet"
            ? "http://localhost:8899"
            : (0, web3_js_1.clusterApiUrl)(cluster), {
            commitment,
            fetch: cross_fetch_1.default,
        });
        const switchboard = env.SWITCHBOARD
            ? new web3_js_1.PublicKey(env.SWITCHBOARD)
            : SwitchboardProgram_js_1.SB_ATTESTATION_PID;
        // TODO: make sync version using local IDLs
        const program = SwitchboardProgram_js_1.SwitchboardProgram.from(connection, undefined, undefined, switchboard);
        // verifier provided env keys
        const payer = new web3_js_1.PublicKey(env.PAYER);
        const verifier = new web3_js_1.PublicKey(env.VERIFIER);
        const rewardReceiver = new web3_js_1.PublicKey(env.REWARD_RECEIVER);
        // load function data
        const functionKey = new web3_js_1.PublicKey(env.FUNCTION_KEY);
        const functionData = env.FUNCTION_DATA && (0, common_1.isHex)(env.FUNCTION_DATA)
            ? Promise.resolve(FunctionAccountData_js_1.FunctionAccountData.decode(Buffer.concat([
                FunctionAccountData_js_1.FunctionAccountData.discriminator,
                Buffer.from(env.FUNCTION_DATA.startsWith("0x")
                    ? env.FUNCTION_DATA.slice(2)
                    : env.FUNCTION_DATA, "hex"),
            ])))
            : undefined;
        // load verifier enclave signer
        const verifierEnclaveSigner = env.VERIFIER_ENCLAVE_SIGNER && (0, common_1.isBase58)(env.VERIFIER_ENCLAVE_SIGNER)
            ? new web3_js_1.PublicKey(env.VERIFIER_ENCLAVE_SIGNER)
            : undefined;
        const queueAuthority = env.QUEUE_AUTHORITY && (0, common_1.isBase58)(env.QUEUE_AUTHORITY)
            ? new web3_js_1.PublicKey(env.QUEUE_AUTHORITY)
            : undefined;
        // load function request info if provided
        const functionRequestKey = env.FUNCTION_REQUEST_KEY && (0, common_1.isBase58)(env.FUNCTION_REQUEST_KEY)
            ? new web3_js_1.PublicKey(env.FUNCTION_REQUEST_KEY)
            : undefined;
        const functionRequestData = !functionRequestKey
            ? undefined
            : env.FUNCTION_REQUEST_DATA && (0, common_1.isHex)(env.FUNCTION_REQUEST_DATA)
                ? Promise.resolve(FunctionRequestAccountData_js_1.FunctionRequestAccountData.decode(Buffer.concat([
                    FunctionRequestAccountData_js_1.FunctionRequestAccountData.discriminator,
                    Buffer.from(env.FUNCTION_REQUEST_DATA.startsWith("0x")
                        ? env.FUNCTION_REQUEST_DATA.slice(2)
                        : env.FUNCTION_REQUEST_DATA, "hex"),
                ])))
                : undefined;
        return new FunctionRunner(program, {
            isSimulation: env.IS_SIMULATION ?? false,
            cluster,
            switchboard,
            functionKey,
            payer,
            verifier,
            rewardReceiver,
            functionData,
            verifierEnclaveSigner,
            queueAuthority,
            functionRequestKey,
            functionRequestData,
        });
    }
    async loadQueueAuthority() {
        if (!this.env.queueAuthority) {
            this.env.queueAuthority = await (async () => {
                const attestationQueueAccountData = await AttestationQueueAccountData_js_1.AttestationQueueAccountData.fetch(this.program, (await this.functionData).attestationQueue);
                if (!attestationQueueAccountData) {
                    throw new Error("AttestationQueue data not found!");
                }
                return attestationQueueAccountData.authority;
            })();
        }
        return this.env.queueAuthority;
    }
    async loadVerifierEnclaveSigner() {
        if (!this.env.verifierEnclaveSigner) {
            this.env.verifierEnclaveSigner = await (async () => {
                const verifierAccountData = await VerifierAccountData_js_1.VerifierAccountData.fetch(this.program, this.verifier);
                if (!verifierAccountData) {
                    throw new Error("Verifier data not found!");
                }
                return verifierAccountData.enclave.enclaveSigner;
            })();
        }
        return this.env.verifierEnclaveSigner;
    }
    async getResult(ixs = [], errorCode = 0) {
        const quote = this.generateQuote();
        // @TODO: check this - will be the source of problems if wrong
        const mrEnclave = quote.slice(432, 432 + 32);
        console.log(`MR ENCLAVE: 0x${quote.slice(432, 432 + 32).toString("hex")}`);
        // TODO: verify this mrEnclave value is present in the function/request config
        const verifyIxn = this.env.functionRequestKey
            ? await this.buildFnRequestVerifyIxn(mrEnclave, errorCode)
            : await this.buildFnVerifyIxn(mrEnclave, errorCode);
        const { blockhash } = await this.connection.getLatestBlockhash();
        const transaction = new web3_js_1.Transaction({
            feePayer: this.payer,
            recentBlockhash: blockhash,
        }).add(verifyIxn, ...ixs);
        transaction.partialSign(this.enclaveSigner);
        return {
            version: 1,
            quote: Array.from(quote),
            fn_key: Array.from(this.env.functionKey.toBytes()),
            signer: Array.from(this.signer.toBytes()),
            fn_request_key: this.env.functionRequestKey
                ? Array.from(this.env.functionRequestKey.toBytes())
                : [],
            fn_request_hash: [],
            chain_result_info: {
                serialized_tx: Array.from(transaction.serialize({
                    requireAllSignatures: false,
                    verifySignatures: false,
                })),
            },
        };
    }
    async emit(ixs = [], errorCode = 0) {
        try {
            const functionResult = await this.getResult(ixs, errorCode);
            console.info(`FN_OUT: ${Buffer.from(JSON.stringify(functionResult)).toString("hex")}`);
        }
        catch (error) {
            throw new Error(`failed to get verify ixn: ${error}`);
        }
    }
    async emitError(errorCode) {
        try {
            const functionResult = await this.getResult([], errorCode);
            console.info(`FN_OUT: ${Buffer.from(JSON.stringify(functionResult)).toString("hex")}`);
        }
        catch (error) {
            throw new Error(`failed to get verify ixn: ${error}`);
        }
    }
    generateQuote() {
        // get sgx quote
        try {
            fs_1.default.accessSync("/dev/attestation/quote");
        }
        catch (err) {
            if (this.env.isSimulation) {
                console.log("WARNING: NOT IN TEE / NO QUOTE GENERATED");
            }
            else {
                throw new Error(`NOT IN TEE / FAILED TO GENERATE QUOTE`);
            }
        }
        const hash = crypto_1.default.createHash("sha256");
        hash.update(this.signer.toBytes());
        const data = Array.from(hash.digest());
        data.length = 64;
        fs_1.default.writeFileSync("/dev/attestation/user_report_data", Buffer.from(data));
        const quote = fs_1.default.readFileSync("/dev/attestation/quote");
        return quote;
    }
    async buildFnVerifyIxn(mrEnclave, errorCode = 0) {
        const functionData = await this.functionData;
        const queueAuthority = await this.loadQueueAuthority();
        const verifierPermission = index_js_1.AttestationPermissionAccount.fromSeed(this.program, queueAuthority, functionData.attestationQueue, this.verifier);
        const verifierEnclaveSigner = await this.loadVerifierEnclaveSigner();
        return (0, functionVerify_js_1.functionVerify)(this.program, {
            params: {
                observedTime: new common_1.BN(unixTimestamp()),
                nextAllowedTimestamp: new common_1.BN(unixTimestamp() + 100),
                errorCode: errorCode,
                mrEnclave: Array.from(mrEnclave),
            },
        }, {
            function: this.env.functionKey,
            functionEnclaveSigner: this.signer,
            verifier: this.env.verifier,
            verifierSigner: verifierEnclaveSigner,
            verifierPermission: verifierPermission.publicKey,
            escrowWallet: functionData.escrowWallet,
            escrowTokenWallet: functionData.escrowTokenWallet,
            attestationQueue: functionData.attestationQueue,
            receiver: this.env.rewardReceiver,
            tokenProgram: anchor_1.utils.token.TOKEN_PROGRAM_ID,
        });
    }
    async buildFnRequestVerifyIxn(mrEnclave, errorCode = 0) {
        if (!this.env.functionRequestData) {
            throw new Error(`Need to provide the function request data to build this instruction`);
        }
        const functionData = await this.functionData;
        const functionRequestData = await this.functionRequestData;
        const queueAuthority = await this.loadQueueAuthority();
        const verifierPermission = index_js_1.AttestationPermissionAccount.fromSeed(this.program, queueAuthority, functionData.attestationQueue, this.verifier);
        const verifierEnclaveSigner = await this.loadVerifierEnclaveSigner();
        return (0, functionRequestVerify_js_1.functionRequestVerify)(this.program, {
            params: {
                observedTime: new common_1.BN(unixTimestamp()),
                errorCode: errorCode,
                mrEnclave: Array.from(mrEnclave),
                requestSlot: functionRequestData.activeRequest.requestSlot,
                containerParamsHash: functionRequestData.containerParamsHash,
            },
        }, {
            request: this.env.functionRequestKey,
            functionEnclaveSigner: this.signer,
            escrow: functionRequestData.escrow,
            function: this.env.functionKey,
            functionEscrow: functionData.escrowTokenWallet,
            verifierQuote: this.env.verifier,
            verifierEnclaveSigner: verifierEnclaveSigner,
            verifierPermission: verifierPermission.publicKey,
            state: this.program.attestationProgramState.publicKey,
            attestationQueue: functionData.attestationQueue,
            receiver: this.env.rewardReceiver,
            tokenProgram: anchor_1.utils.token.TOKEN_PROGRAM_ID,
        });
    }
}
exports.FunctionRunner = FunctionRunner;
