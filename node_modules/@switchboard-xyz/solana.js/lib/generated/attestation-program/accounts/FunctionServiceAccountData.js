import * as types from "../types/index.js"; // eslint-disable-line @typescript-eslint/no-unused-vars
import * as borsh from "@coral-xyz/borsh"; // eslint-disable-line @typescript-eslint/no-unused-vars
import { PublicKey } from "@solana/web3.js";
import { BN } from "@switchboard-xyz/common"; // eslint-disable-line @typescript-eslint/no-unused-vars
/**
 * A [`FunctionServiceAccountData`] represents a long running function for a given [`FunctionAccountData`].
 * A service determines the execution parameters (environment variables, oracle config, cost).
 */
export class FunctionServiceAccountData {
    /** The Attestation Queue for this service, responsible for verifying any SGX quotes. */
    attestationQueue;
    /** The service workerr that is executing the managed service. */
    serviceWorker;
    /**
     * The status of the current service.
     * 0 = disabled, 1 = active.
     */
    status;
    /** Flag to disable the service and prevent new verification requests. */
    isDisabled;
    /** Whether the enclave is in progress for being rotated. Used for quote verifiers to filter and find pending verification requests. */
    enclaveRotationStatus;
    /** The last reported error code if the most recent response was a failure */
    errorStatus;
    /** Signer allowed to manage the service. */
    authority;
    /** The pubkey of the [`FunctionAccountData`] that this service belongs to. */
    function;
    escrowWallet;
    /** The TokenAccount with funds for the escrow. */
    escrowTokenWallet;
    /** The name of the service for easier identification. */
    name;
    /** The metadata of the service for easier identification. */
    metadata;
    /** The unix timestamp when the service was created. */
    createdAt;
    /** The unix timestamp when the service was last updated. */
    updatedAt;
    /** Represents the state of the quote verifiers enclave. */
    enclave;
    /** The previous verified quote. Used to facilitate smooth transitions during signer rotations. */
    previousEnclave;
    /** The pending [`Quote`] indicating a signer rotation is in-progress. */
    pendingEnclave;
    /** The timestamp when the signer was last rotated. */
    lastRotationTimestamp;
    /** The index on the queue of the verifier that is assigned to verify the SGX quote. */
    queueIdx;
    /** The maximum number of bytes to pass to the container params. */
    maxContainerParamsLen;
    /**
     * Hash of the serialized container_params to prevent RPC tampering.
     * Should be verified within your function to ensure you are using the correct parameters.
     */
    containerParamsHash;
    /** The stringified container params to pass to the function. */
    containerParams;
    /** The size of the enclave to reserve, in bytes. */
    enclaveSize;
    /** */
    cpu;
    /** Reserved. */
    ebuf;
    static discriminator = Buffer.from([
        2, 2, 33, 121, 177, 19, 195, 195,
    ]);
    static layout = borsh.struct([
        borsh.publicKey("attestationQueue"),
        borsh.publicKey("serviceWorker"),
        types.ServiceStatus.layout("status"),
        types.ResourceLevel.layout("isDisabled"),
        types.EnclaveRotationStatus.layout("enclaveRotationStatus"),
        borsh.u8("errorStatus"),
        borsh.publicKey("authority"),
        borsh.publicKey("function"),
        borsh.publicKey("escrowWallet"),
        borsh.publicKey("escrowTokenWallet"),
        borsh.array(borsh.u8(), 64, "name"),
        borsh.array(borsh.u8(), 256, "metadata"),
        borsh.i64("createdAt"),
        borsh.i64("updatedAt"),
        types.BorshQuote.layout("enclave"),
        types.BorshQuote.layout("previousEnclave"),
        types.BorshQuote.layout("pendingEnclave"),
        borsh.i64("lastRotationTimestamp"),
        borsh.u32("queueIdx"),
        borsh.u32("maxContainerParamsLen"),
        borsh.array(borsh.u8(), 32, "containerParamsHash"),
        borsh.vecU8("containerParams"),
        borsh.u64("enclaveSize"),
        borsh.u64("cpu"),
        borsh.array(borsh.u8(), 512, "ebuf"),
    ]);
    constructor(fields) {
        this.attestationQueue = fields.attestationQueue;
        this.serviceWorker = fields.serviceWorker;
        this.status = fields.status;
        this.isDisabled = fields.isDisabled;
        this.enclaveRotationStatus = fields.enclaveRotationStatus;
        this.errorStatus = fields.errorStatus;
        this.authority = fields.authority;
        this.function = fields.function;
        this.escrowWallet = fields.escrowWallet;
        this.escrowTokenWallet = fields.escrowTokenWallet;
        this.name = fields.name;
        this.metadata = fields.metadata;
        this.createdAt = fields.createdAt;
        this.updatedAt = fields.updatedAt;
        this.enclave = new types.BorshQuote({ ...fields.enclave });
        this.previousEnclave = new types.BorshQuote({ ...fields.previousEnclave });
        this.pendingEnclave = new types.BorshQuote({ ...fields.pendingEnclave });
        this.lastRotationTimestamp = fields.lastRotationTimestamp;
        this.queueIdx = fields.queueIdx;
        this.maxContainerParamsLen = fields.maxContainerParamsLen;
        this.containerParamsHash = fields.containerParamsHash;
        this.containerParams = fields.containerParams;
        this.enclaveSize = fields.enclaveSize;
        this.cpu = fields.cpu;
        this.ebuf = fields.ebuf;
    }
    static async fetch(program, address, programId = program.attestationProgramId) {
        const info = await program.connection.getAccountInfo(address);
        if (info === null) {
            return null;
        }
        if (!info.owner.equals(programId)) {
            throw new Error("account doesn't belong to this program");
        }
        return this.decode(info.data);
    }
    static async fetchMultiple(program, addresses, programId = program.attestationProgramId) {
        const infos = await program.connection.getMultipleAccountsInfo(addresses);
        return infos.map((info) => {
            if (info === null) {
                return null;
            }
            if (!info.owner.equals(programId)) {
                throw new Error("account doesn't belong to this program");
            }
            return this.decode(info.data);
        });
    }
    static decode(data) {
        if (!data.slice(0, 8).equals(FunctionServiceAccountData.discriminator)) {
            throw new Error("invalid account discriminator");
        }
        const dec = FunctionServiceAccountData.layout.decode(data.slice(8));
        return new FunctionServiceAccountData({
            attestationQueue: dec.attestationQueue,
            serviceWorker: dec.serviceWorker,
            status: types.ServiceStatus.fromDecoded(dec.status),
            isDisabled: types.ResourceLevel.fromDecoded(dec.isDisabled),
            enclaveRotationStatus: types.EnclaveRotationStatus.fromDecoded(dec.enclaveRotationStatus),
            errorStatus: dec.errorStatus,
            authority: dec.authority,
            function: dec.function,
            escrowWallet: dec.escrowWallet,
            escrowTokenWallet: dec.escrowTokenWallet,
            name: dec.name,
            metadata: dec.metadata,
            createdAt: dec.createdAt,
            updatedAt: dec.updatedAt,
            enclave: types.BorshQuote.fromDecoded(dec.enclave),
            previousEnclave: types.BorshQuote.fromDecoded(dec.previousEnclave),
            pendingEnclave: types.BorshQuote.fromDecoded(dec.pendingEnclave),
            lastRotationTimestamp: dec.lastRotationTimestamp,
            queueIdx: dec.queueIdx,
            maxContainerParamsLen: dec.maxContainerParamsLen,
            containerParamsHash: dec.containerParamsHash,
            containerParams: new Uint8Array(dec.containerParams.buffer, dec.containerParams.byteOffset, dec.containerParams.length),
            enclaveSize: dec.enclaveSize,
            cpu: dec.cpu,
            ebuf: dec.ebuf,
        });
    }
    toJSON() {
        return {
            attestationQueue: this.attestationQueue.toString(),
            serviceWorker: this.serviceWorker.toString(),
            status: this.status.toJSON(),
            isDisabled: this.isDisabled.toJSON(),
            enclaveRotationStatus: this.enclaveRotationStatus.toJSON(),
            errorStatus: this.errorStatus,
            authority: this.authority.toString(),
            function: this.function.toString(),
            escrowWallet: this.escrowWallet.toString(),
            escrowTokenWallet: this.escrowTokenWallet.toString(),
            name: this.name,
            metadata: this.metadata,
            createdAt: this.createdAt.toString(),
            updatedAt: this.updatedAt.toString(),
            enclave: this.enclave.toJSON(),
            previousEnclave: this.previousEnclave.toJSON(),
            pendingEnclave: this.pendingEnclave.toJSON(),
            lastRotationTimestamp: this.lastRotationTimestamp.toString(),
            queueIdx: this.queueIdx,
            maxContainerParamsLen: this.maxContainerParamsLen,
            containerParamsHash: this.containerParamsHash,
            containerParams: Array.from(this.containerParams.values()),
            enclaveSize: this.enclaveSize.toString(),
            cpu: this.cpu.toString(),
            ebuf: this.ebuf,
        };
    }
    static fromJSON(obj) {
        return new FunctionServiceAccountData({
            attestationQueue: new PublicKey(obj.attestationQueue),
            serviceWorker: new PublicKey(obj.serviceWorker),
            status: types.ServiceStatus.fromJSON(obj.status),
            isDisabled: types.ResourceLevel.fromJSON(obj.isDisabled),
            enclaveRotationStatus: types.EnclaveRotationStatus.fromJSON(obj.enclaveRotationStatus),
            errorStatus: obj.errorStatus,
            authority: new PublicKey(obj.authority),
            function: new PublicKey(obj.function),
            escrowWallet: new PublicKey(obj.escrowWallet),
            escrowTokenWallet: new PublicKey(obj.escrowTokenWallet),
            name: obj.name,
            metadata: obj.metadata,
            createdAt: new BN(obj.createdAt),
            updatedAt: new BN(obj.updatedAt),
            enclave: types.BorshQuote.fromJSON(obj.enclave),
            previousEnclave: types.BorshQuote.fromJSON(obj.previousEnclave),
            pendingEnclave: types.BorshQuote.fromJSON(obj.pendingEnclave),
            lastRotationTimestamp: new BN(obj.lastRotationTimestamp),
            queueIdx: obj.queueIdx,
            maxContainerParamsLen: obj.maxContainerParamsLen,
            containerParamsHash: obj.containerParamsHash,
            containerParams: Uint8Array.from(obj.containerParams),
            enclaveSize: new BN(obj.enclaveSize),
            cpu: new BN(obj.cpu),
            ebuf: obj.ebuf,
        });
    }
}
