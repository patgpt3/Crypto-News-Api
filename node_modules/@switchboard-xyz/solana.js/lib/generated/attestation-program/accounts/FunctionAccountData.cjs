"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionAccountData = void 0;
const types = __importStar(require("../types/index.cjs")); // eslint-disable-line @typescript-eslint/no-unused-vars
const borsh = __importStar(require("@coral-xyz/borsh")); // eslint-disable-line @typescript-eslint/no-unused-vars
const web3_js_1 = require("@solana/web3.js");
const common_1 = require("@switchboard-xyz/common"); // eslint-disable-line @typescript-eslint/no-unused-vars
class FunctionAccountData {
    /** Whether the function is invoked on a schedule or by request */
    isScheduled;
    /** Whether the function has been manually triggered with the function_trigger instruction */
    isTriggered;
    /** The function permissions granted by the attestation_queue.authority */
    permissions;
    status;
    /** PDA bump. */
    bump;
    /** The payer who originally created the function. Cannot change, used to derive PDA. */
    creatorSeed;
    /** The name of the function for easier identification. */
    name;
    /** The metadata of the function for easier identification. */
    metadata;
    /** The Solana slot when the function was created. (PDA) */
    createdAtSlot;
    /** The unix timestamp when the function was created. */
    createdAt;
    /** The unix timestamp when the function config (container, registry, version, or schedule) was changed. */
    updatedAt;
    /** The enclave quote */
    enclave;
    /** An array of permitted mr_enclave measurements for the function. */
    mrEnclaves;
    /** The off-chain registry to fetch the function container from. */
    containerRegistry;
    /** The identifier of the container in the given container_registry. */
    container;
    /** The version tag of the container to pull. */
    version;
    /** The expected schema for the container params. */
    paramsSchema;
    /** The default params passed to the container during scheduled execution. */
    defaultContainerParams;
    /** The authority of the function which is authorized to make account changes. */
    authority;
    /** The address of the AttestationQueueAccountData that will be processing function requests and verifying the function measurements. */
    attestationQueue;
    /** An incrementer used to rotate through an AttestationQueue's verifiers. */
    queueIdx;
    /** The address_lookup_table of the function used to increase the number of accounts we can fit into a function result. */
    addressLookupTable;
    /** The cron schedule to run the function on. */
    schedule;
    /** The unix timestamp when the function was last run. */
    lastExecutionTimestamp;
    /** The unix timestamp when the function is allowed to run next. */
    nextAllowedTimestamp;
    /** The number of times to trigger the function upon the next invocation. */
    triggerCount;
    /** Time this function has been sitting in an explicitly triggered state */
    triggeredSince;
    /** UNUSED. The unix timestamp when the current permissions expire. */
    permissionExpiration;
    /** Number of requests created for this function. Used to prevent closing when there are live requests. */
    numRequests;
    /** Whether custom requests have been disabled for this function. */
    requestsDisabled;
    /**
     * Whether new requests need to be authorized by the FunctionAccount authority before being initialized.
     * Useful if you want to use CPIs to control request account creation.
     */
    requestsRequireAuthorization;
    /** DEPRECATED. */
    reserved1;
    /**
     * The dev fee that is paid out from the request's escrow to the function's escrow on each successful invocation.
     * This is used to reward the function maintainer for providing the function.
     * 0 = No Fee. Sender = requests's escrow_token_wallet. Receiver = function's reward_token_wallet.
     */
    requestsDevFee;
    /** The SwitchboardWallet that will handle pre-funding rewards paid out to function verifiers. */
    escrowWallet;
    /** The escrow_wallet TokenAccount that handles pre-funding rewards paid out to function runners. */
    escrowTokenWallet;
    /**
     * The SwitchboardWallet that will handle acruing rewards from requests.
     * Defaults to the escrow_wallet.
     */
    rewardEscrowWallet;
    /** The reward_escrow_wallet TokenAccount used to acrue rewards from requests made with custom parameters. */
    rewardEscrowTokenWallet;
    /** The last reported error code if the most recent response was a failure */
    errorStatus;
    /** Number of routines created for this function. Used to prevent closing when there are live routines. */
    numRoutines;
    /** Whether custom routines have been disabled for this function. */
    routinesDisabled;
    /**
     * Whether new routines need to be authorized by the FunctionAccount authority before being initialized.
     * Useful if you want to provide AccessControl and only allow certain parties to run routines.
     */
    routinesRequireAuthorization;
    /**
     * The fee that is paid out from the routine's escrow to the function's escrow on each successful invocation.
     * This is used to reward the function maintainer for providing the function.
     * 0 = No Fee. Sender = routine's escrow_token_wallet. Receiver = function's reward_token_wallet.
     */
    routinesDevFee;
    /** The functions MRENCLAVE measurement dictating the contents of the secure enclave. */
    mrEnclave;
    /** The VerificationStatus of the quote. */
    verificationStatus;
    /** The unix timestamp when the quote was last verified. */
    verificationTimestamp;
    /** The unix timestamp when the quotes verification status expires. */
    validUntil;
    /** Number of services created for this function. Used to prevent closing when there are live services. */
    numServices;
    /** Whether custom services have been disabled for this function. */
    servicesEnabled;
    /**
     * Whether new services need to be authorized by the FunctionAccount authority before being initialized.
     * Useful if you want to provide AccessControl and only allow certain parties to run services.
     */
    servicesRequireAuthorization;
    /**
     * The number of seconds before a service needs to rotate their keypair, excluding reboots.
     * This is used to payout the services_dev_fee each time the signer is rotated.
     * 0 = No rotation required.
     */
    servicesSignerRotationInterval;
    /**
     * The fee that is paid out from the service's escrow to the function's escrow on each successful signer rotation.
     * This is used to reward the function maintainer for providing the function.
     * 0 = No Fee. Sender = services's escrow_token_wallet. Receiver = function's reward_token_wallet.
     */
    servicesDevFee;
    /** Reserved. */
    ebuf;
    static discriminator = Buffer.from([
        76, 139, 47, 44, 240, 182, 148, 200,
    ]);
    static layout = borsh.struct([
        borsh.u8("isScheduled"),
        borsh.u8("isTriggered"),
        borsh.u32("permissions"),
        types.FunctionStatus.layout("status"),
        borsh.u8("bump"),
        borsh.array(borsh.u8(), 32, "creatorSeed"),
        borsh.array(borsh.u8(), 64, "name"),
        borsh.array(borsh.u8(), 256, "metadata"),
        borsh.u64("createdAtSlot"),
        borsh.i64("createdAt"),
        borsh.i64("updatedAt"),
        types.Quote.layout("enclave"),
        borsh.array(borsh.array(borsh.u8(), 32), 32, "mrEnclaves"),
        borsh.array(borsh.u8(), 64, "containerRegistry"),
        borsh.array(borsh.u8(), 64, "container"),
        borsh.array(borsh.u8(), 32, "version"),
        borsh.array(borsh.u8(), 256, "paramsSchema"),
        borsh.array(borsh.u8(), 256, "defaultContainerParams"),
        borsh.publicKey("authority"),
        borsh.publicKey("attestationQueue"),
        borsh.u32("queueIdx"),
        borsh.publicKey("addressLookupTable"),
        borsh.array(borsh.u8(), 64, "schedule"),
        borsh.i64("lastExecutionTimestamp"),
        borsh.i64("nextAllowedTimestamp"),
        borsh.u64("triggerCount"),
        borsh.i64("triggeredSince"),
        borsh.i64("permissionExpiration"),
        borsh.u64("numRequests"),
        borsh.u8("requestsDisabled"),
        borsh.u8("requestsRequireAuthorization"),
        borsh.array(borsh.u8(), 8, "reserved1"),
        borsh.u64("requestsDevFee"),
        borsh.publicKey("escrowWallet"),
        borsh.publicKey("escrowTokenWallet"),
        borsh.publicKey("rewardEscrowWallet"),
        borsh.publicKey("rewardEscrowTokenWallet"),
        borsh.u8("errorStatus"),
        borsh.u64("numRoutines"),
        types.BoolWithLock.layout("routinesDisabled"),
        borsh.u8("routinesRequireAuthorization"),
        borsh.u64("routinesDevFee"),
        borsh.array(borsh.u8(), 32, "mrEnclave"),
        borsh.u8("verificationStatus"),
        borsh.i64("verificationTimestamp"),
        borsh.i64("validUntil"),
        borsh.u64("numServices"),
        types.BoolWithLock.layout("servicesEnabled"),
        borsh.u8("servicesRequireAuthorization"),
        borsh.i64("servicesSignerRotationInterval"),
        borsh.u64("servicesDevFee"),
        borsh.array(borsh.u8(), 930, "ebuf"),
    ]);
    constructor(fields) {
        this.isScheduled = fields.isScheduled;
        this.isTriggered = fields.isTriggered;
        this.permissions = fields.permissions;
        this.status = fields.status;
        this.bump = fields.bump;
        this.creatorSeed = fields.creatorSeed;
        this.name = fields.name;
        this.metadata = fields.metadata;
        this.createdAtSlot = fields.createdAtSlot;
        this.createdAt = fields.createdAt;
        this.updatedAt = fields.updatedAt;
        this.enclave = new types.Quote({ ...fields.enclave });
        this.mrEnclaves = fields.mrEnclaves;
        this.containerRegistry = fields.containerRegistry;
        this.container = fields.container;
        this.version = fields.version;
        this.paramsSchema = fields.paramsSchema;
        this.defaultContainerParams = fields.defaultContainerParams;
        this.authority = fields.authority;
        this.attestationQueue = fields.attestationQueue;
        this.queueIdx = fields.queueIdx;
        this.addressLookupTable = fields.addressLookupTable;
        this.schedule = fields.schedule;
        this.lastExecutionTimestamp = fields.lastExecutionTimestamp;
        this.nextAllowedTimestamp = fields.nextAllowedTimestamp;
        this.triggerCount = fields.triggerCount;
        this.triggeredSince = fields.triggeredSince;
        this.permissionExpiration = fields.permissionExpiration;
        this.numRequests = fields.numRequests;
        this.requestsDisabled = fields.requestsDisabled;
        this.requestsRequireAuthorization = fields.requestsRequireAuthorization;
        this.reserved1 = fields.reserved1;
        this.requestsDevFee = fields.requestsDevFee;
        this.escrowWallet = fields.escrowWallet;
        this.escrowTokenWallet = fields.escrowTokenWallet;
        this.rewardEscrowWallet = fields.rewardEscrowWallet;
        this.rewardEscrowTokenWallet = fields.rewardEscrowTokenWallet;
        this.errorStatus = fields.errorStatus;
        this.numRoutines = fields.numRoutines;
        this.routinesDisabled = fields.routinesDisabled;
        this.routinesRequireAuthorization = fields.routinesRequireAuthorization;
        this.routinesDevFee = fields.routinesDevFee;
        this.mrEnclave = fields.mrEnclave;
        this.verificationStatus = fields.verificationStatus;
        this.verificationTimestamp = fields.verificationTimestamp;
        this.validUntil = fields.validUntil;
        this.numServices = fields.numServices;
        this.servicesEnabled = fields.servicesEnabled;
        this.servicesRequireAuthorization = fields.servicesRequireAuthorization;
        this.servicesSignerRotationInterval = fields.servicesSignerRotationInterval;
        this.servicesDevFee = fields.servicesDevFee;
        this.ebuf = fields.ebuf;
    }
    static async fetch(program, address, programId = program.attestationProgramId) {
        const info = await program.connection.getAccountInfo(address);
        if (info === null) {
            return null;
        }
        if (!info.owner.equals(programId)) {
            throw new Error("account doesn't belong to this program");
        }
        return this.decode(info.data);
    }
    static async fetchMultiple(program, addresses, programId = program.attestationProgramId) {
        const infos = await program.connection.getMultipleAccountsInfo(addresses);
        return infos.map((info) => {
            if (info === null) {
                return null;
            }
            if (!info.owner.equals(programId)) {
                throw new Error("account doesn't belong to this program");
            }
            return this.decode(info.data);
        });
    }
    static decode(data) {
        if (!data.slice(0, 8).equals(FunctionAccountData.discriminator)) {
            throw new Error("invalid account discriminator");
        }
        const dec = FunctionAccountData.layout.decode(data.slice(8));
        return new FunctionAccountData({
            isScheduled: dec.isScheduled,
            isTriggered: dec.isTriggered,
            permissions: dec.permissions,
            status: types.FunctionStatus.fromDecoded(dec.status),
            bump: dec.bump,
            creatorSeed: dec.creatorSeed,
            name: dec.name,
            metadata: dec.metadata,
            createdAtSlot: dec.createdAtSlot,
            createdAt: dec.createdAt,
            updatedAt: dec.updatedAt,
            enclave: types.Quote.fromDecoded(dec.enclave),
            mrEnclaves: dec.mrEnclaves,
            containerRegistry: dec.containerRegistry,
            container: dec.container,
            version: dec.version,
            paramsSchema: dec.paramsSchema,
            defaultContainerParams: dec.defaultContainerParams,
            authority: dec.authority,
            attestationQueue: dec.attestationQueue,
            queueIdx: dec.queueIdx,
            addressLookupTable: dec.addressLookupTable,
            schedule: dec.schedule,
            lastExecutionTimestamp: dec.lastExecutionTimestamp,
            nextAllowedTimestamp: dec.nextAllowedTimestamp,
            triggerCount: dec.triggerCount,
            triggeredSince: dec.triggeredSince,
            permissionExpiration: dec.permissionExpiration,
            numRequests: dec.numRequests,
            requestsDisabled: dec.requestsDisabled,
            requestsRequireAuthorization: dec.requestsRequireAuthorization,
            reserved1: dec.reserved1,
            requestsDevFee: dec.requestsDevFee,
            escrowWallet: dec.escrowWallet,
            escrowTokenWallet: dec.escrowTokenWallet,
            rewardEscrowWallet: dec.rewardEscrowWallet,
            rewardEscrowTokenWallet: dec.rewardEscrowTokenWallet,
            errorStatus: dec.errorStatus,
            numRoutines: dec.numRoutines,
            routinesDisabled: types.BoolWithLock.fromDecoded(dec.routinesDisabled),
            routinesRequireAuthorization: dec.routinesRequireAuthorization,
            routinesDevFee: dec.routinesDevFee,
            mrEnclave: dec.mrEnclave,
            verificationStatus: dec.verificationStatus,
            verificationTimestamp: dec.verificationTimestamp,
            validUntil: dec.validUntil,
            numServices: dec.numServices,
            servicesEnabled: types.BoolWithLock.fromDecoded(dec.servicesEnabled),
            servicesRequireAuthorization: dec.servicesRequireAuthorization,
            servicesSignerRotationInterval: dec.servicesSignerRotationInterval,
            servicesDevFee: dec.servicesDevFee,
            ebuf: dec.ebuf,
        });
    }
    toJSON() {
        return {
            isScheduled: this.isScheduled,
            isTriggered: this.isTriggered,
            permissions: this.permissions,
            status: this.status.toJSON(),
            bump: this.bump,
            creatorSeed: this.creatorSeed,
            name: this.name,
            metadata: this.metadata,
            createdAtSlot: this.createdAtSlot.toString(),
            createdAt: this.createdAt.toString(),
            updatedAt: this.updatedAt.toString(),
            enclave: this.enclave.toJSON(),
            mrEnclaves: this.mrEnclaves,
            containerRegistry: this.containerRegistry,
            container: this.container,
            version: this.version,
            paramsSchema: this.paramsSchema,
            defaultContainerParams: this.defaultContainerParams,
            authority: this.authority.toString(),
            attestationQueue: this.attestationQueue.toString(),
            queueIdx: this.queueIdx,
            addressLookupTable: this.addressLookupTable.toString(),
            schedule: this.schedule,
            lastExecutionTimestamp: this.lastExecutionTimestamp.toString(),
            nextAllowedTimestamp: this.nextAllowedTimestamp.toString(),
            triggerCount: this.triggerCount.toString(),
            triggeredSince: this.triggeredSince.toString(),
            permissionExpiration: this.permissionExpiration.toString(),
            numRequests: this.numRequests.toString(),
            requestsDisabled: this.requestsDisabled,
            requestsRequireAuthorization: this.requestsRequireAuthorization,
            reserved1: this.reserved1,
            requestsDevFee: this.requestsDevFee.toString(),
            escrowWallet: this.escrowWallet.toString(),
            escrowTokenWallet: this.escrowTokenWallet.toString(),
            rewardEscrowWallet: this.rewardEscrowWallet.toString(),
            rewardEscrowTokenWallet: this.rewardEscrowTokenWallet.toString(),
            errorStatus: this.errorStatus,
            numRoutines: this.numRoutines.toString(),
            routinesDisabled: this.routinesDisabled.toJSON(),
            routinesRequireAuthorization: this.routinesRequireAuthorization,
            routinesDevFee: this.routinesDevFee.toString(),
            mrEnclave: this.mrEnclave,
            verificationStatus: this.verificationStatus,
            verificationTimestamp: this.verificationTimestamp.toString(),
            validUntil: this.validUntil.toString(),
            numServices: this.numServices.toString(),
            servicesEnabled: this.servicesEnabled.toJSON(),
            servicesRequireAuthorization: this.servicesRequireAuthorization,
            servicesSignerRotationInterval: this.servicesSignerRotationInterval.toString(),
            servicesDevFee: this.servicesDevFee.toString(),
            ebuf: this.ebuf,
        };
    }
    static fromJSON(obj) {
        return new FunctionAccountData({
            isScheduled: obj.isScheduled,
            isTriggered: obj.isTriggered,
            permissions: obj.permissions,
            status: types.FunctionStatus.fromJSON(obj.status),
            bump: obj.bump,
            creatorSeed: obj.creatorSeed,
            name: obj.name,
            metadata: obj.metadata,
            createdAtSlot: new common_1.BN(obj.createdAtSlot),
            createdAt: new common_1.BN(obj.createdAt),
            updatedAt: new common_1.BN(obj.updatedAt),
            enclave: types.Quote.fromJSON(obj.enclave),
            mrEnclaves: obj.mrEnclaves,
            containerRegistry: obj.containerRegistry,
            container: obj.container,
            version: obj.version,
            paramsSchema: obj.paramsSchema,
            defaultContainerParams: obj.defaultContainerParams,
            authority: new web3_js_1.PublicKey(obj.authority),
            attestationQueue: new web3_js_1.PublicKey(obj.attestationQueue),
            queueIdx: obj.queueIdx,
            addressLookupTable: new web3_js_1.PublicKey(obj.addressLookupTable),
            schedule: obj.schedule,
            lastExecutionTimestamp: new common_1.BN(obj.lastExecutionTimestamp),
            nextAllowedTimestamp: new common_1.BN(obj.nextAllowedTimestamp),
            triggerCount: new common_1.BN(obj.triggerCount),
            triggeredSince: new common_1.BN(obj.triggeredSince),
            permissionExpiration: new common_1.BN(obj.permissionExpiration),
            numRequests: new common_1.BN(obj.numRequests),
            requestsDisabled: obj.requestsDisabled,
            requestsRequireAuthorization: obj.requestsRequireAuthorization,
            reserved1: obj.reserved1,
            requestsDevFee: new common_1.BN(obj.requestsDevFee),
            escrowWallet: new web3_js_1.PublicKey(obj.escrowWallet),
            escrowTokenWallet: new web3_js_1.PublicKey(obj.escrowTokenWallet),
            rewardEscrowWallet: new web3_js_1.PublicKey(obj.rewardEscrowWallet),
            rewardEscrowTokenWallet: new web3_js_1.PublicKey(obj.rewardEscrowTokenWallet),
            errorStatus: obj.errorStatus,
            numRoutines: new common_1.BN(obj.numRoutines),
            routinesDisabled: types.BoolWithLock.fromJSON(obj.routinesDisabled),
            routinesRequireAuthorization: obj.routinesRequireAuthorization,
            routinesDevFee: new common_1.BN(obj.routinesDevFee),
            mrEnclave: obj.mrEnclave,
            verificationStatus: obj.verificationStatus,
            verificationTimestamp: new common_1.BN(obj.verificationTimestamp),
            validUntil: new common_1.BN(obj.validUntil),
            numServices: new common_1.BN(obj.numServices),
            servicesEnabled: types.BoolWithLock.fromJSON(obj.servicesEnabled),
            servicesRequireAuthorization: obj.servicesRequireAuthorization,
            servicesSignerRotationInterval: new common_1.BN(obj.servicesSignerRotationInterval),
            servicesDevFee: new common_1.BN(obj.servicesDevFee),
            ebuf: obj.ebuf,
        });
    }
}
exports.FunctionAccountData = FunctionAccountData;
