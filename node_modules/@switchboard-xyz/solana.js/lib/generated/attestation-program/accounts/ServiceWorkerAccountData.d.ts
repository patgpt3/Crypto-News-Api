/// <reference types="node" resolution-mode="require"/>
import type { SwitchboardProgram } from "../../../SwitchboardProgram.js";
import * as types from "../types/index.js";
import { PublicKey } from "@solana/web3.js";
import { BN } from "@switchboard-xyz/common";
export interface ServiceWorkerAccountDataFields {
    status: number;
    /** Trusted. The region the server will be run within. */
    region: types.ServerRegionKind;
    /** Trusted. The zone where the server will be run within. */
    zone: types.ServerZoneKind;
    /** Signer allowed to configure the service worker.. */
    authority: PublicKey;
    /** The Attestation Queue for this service worker, responsible for verifying any SGX quotes. */
    attestationQueue: PublicKey;
    /** The unix timestamp when the quote was created. */
    createdAt: BN;
    /** The unix timestamp when the service was last updated. */
    updatedAt: BN;
    /** Whether the service worker authority needs to approve new services to use the worker. */
    permissionsRequired: types.BoolWithLockKind;
    /** The available amount of memory on the machine. Trusted to be set correctly by the service worker authority. */
    availableEnclaveSize: BN;
    /** The maximum amount of RAM available to run Trusted Execution Environments (TEEs). */
    maxEnclaveSize: BN;
    /** The maximum CPU that can be given to a service. */
    maxCpu: BN;
    /** The cost to use this service worker. Should this be cost per epoch? */
    enclaveCost: BN;
    /**
     * The SwitchboardWallet account containing the reward escrow for verifying quotes on-chain.
     * We should set this whenever the operator changes so we dont need to pass another account and can verify with has_one.
     */
    rewardEscrow: PublicKey;
    /** The addresses of the services who are being executed by the service worker. */
    services: Array<types.ServiceRowFields>;
    /** The length of valid services for the service worker. */
    servicesLen: number;
    /** The maximum number of services allowed to run the service. */
    maxServicesLen: number;
    /** Reserved. */
    ebuf: Array<number>;
}
export interface ServiceWorkerAccountDataJSON {
    status: number;
    /** Trusted. The region the server will be run within. */
    region: types.ServerRegionJSON;
    /** Trusted. The zone where the server will be run within. */
    zone: types.ServerZoneJSON;
    /** Signer allowed to configure the service worker.. */
    authority: string;
    /** The Attestation Queue for this service worker, responsible for verifying any SGX quotes. */
    attestationQueue: string;
    /** The unix timestamp when the quote was created. */
    createdAt: string;
    /** The unix timestamp when the service was last updated. */
    updatedAt: string;
    /** Whether the service worker authority needs to approve new services to use the worker. */
    permissionsRequired: types.BoolWithLockJSON;
    /** The available amount of memory on the machine. Trusted to be set correctly by the service worker authority. */
    availableEnclaveSize: string;
    /** The maximum amount of RAM available to run Trusted Execution Environments (TEEs). */
    maxEnclaveSize: string;
    /** The maximum CPU that can be given to a service. */
    maxCpu: string;
    /** The cost to use this service worker. Should this be cost per epoch? */
    enclaveCost: string;
    /**
     * The SwitchboardWallet account containing the reward escrow for verifying quotes on-chain.
     * We should set this whenever the operator changes so we dont need to pass another account and can verify with has_one.
     */
    rewardEscrow: string;
    /** The addresses of the services who are being executed by the service worker. */
    services: Array<types.ServiceRowJSON>;
    /** The length of valid services for the service worker. */
    servicesLen: number;
    /** The maximum number of services allowed to run the service. */
    maxServicesLen: number;
    /** Reserved. */
    ebuf: Array<number>;
}
/** A [`ServiceWorkerAccountData`] represents a given server or kubernetes cluster that is ready to spin up new workloads. */
export declare class ServiceWorkerAccountData {
    readonly status: number;
    /** Trusted. The region the server will be run within. */
    readonly region: types.ServerRegionKind;
    /** Trusted. The zone where the server will be run within. */
    readonly zone: types.ServerZoneKind;
    /** Signer allowed to configure the service worker.. */
    readonly authority: PublicKey;
    /** The Attestation Queue for this service worker, responsible for verifying any SGX quotes. */
    readonly attestationQueue: PublicKey;
    /** The unix timestamp when the quote was created. */
    readonly createdAt: BN;
    /** The unix timestamp when the service was last updated. */
    readonly updatedAt: BN;
    /** Whether the service worker authority needs to approve new services to use the worker. */
    readonly permissionsRequired: types.BoolWithLockKind;
    /** The available amount of memory on the machine. Trusted to be set correctly by the service worker authority. */
    readonly availableEnclaveSize: BN;
    /** The maximum amount of RAM available to run Trusted Execution Environments (TEEs). */
    readonly maxEnclaveSize: BN;
    /** The maximum CPU that can be given to a service. */
    readonly maxCpu: BN;
    /** The cost to use this service worker. Should this be cost per epoch? */
    readonly enclaveCost: BN;
    /**
     * The SwitchboardWallet account containing the reward escrow for verifying quotes on-chain.
     * We should set this whenever the operator changes so we dont need to pass another account and can verify with has_one.
     */
    readonly rewardEscrow: PublicKey;
    /** The addresses of the services who are being executed by the service worker. */
    readonly services: Array<types.ServiceRow>;
    /** The length of valid services for the service worker. */
    readonly servicesLen: number;
    /** The maximum number of services allowed to run the service. */
    readonly maxServicesLen: number;
    /** Reserved. */
    readonly ebuf: Array<number>;
    static readonly discriminator: Buffer;
    static readonly layout: any;
    constructor(fields: ServiceWorkerAccountDataFields);
    static fetch(program: SwitchboardProgram, address: PublicKey, programId?: PublicKey): Promise<ServiceWorkerAccountData | null>;
    static fetchMultiple(program: SwitchboardProgram, addresses: PublicKey[], programId?: PublicKey): Promise<Array<ServiceWorkerAccountData | null>>;
    static decode(data: Buffer): ServiceWorkerAccountData;
    toJSON(): ServiceWorkerAccountDataJSON;
    static fromJSON(obj: ServiceWorkerAccountDataJSON): ServiceWorkerAccountData;
}
//# sourceMappingURL=ServiceWorkerAccountData.d.ts.map