import * as types from "../types/index.js"; // eslint-disable-line @typescript-eslint/no-unused-vars
import * as borsh from "@coral-xyz/borsh"; // eslint-disable-line @typescript-eslint/no-unused-vars
import { PublicKey } from "@solana/web3.js";
import { BN } from "@switchboard-xyz/common"; // eslint-disable-line @typescript-eslint/no-unused-vars
/** A [`ServiceWorkerAccountData`] represents a given server or kubernetes cluster that is ready to spin up new workloads. */
export class ServiceWorkerAccountData {
    status;
    /** Trusted. The region the server will be run within. */
    region;
    /** Trusted. The zone where the server will be run within. */
    zone;
    /** Signer allowed to configure the service worker.. */
    authority;
    /** The Attestation Queue for this service worker, responsible for verifying any SGX quotes. */
    attestationQueue;
    /** The unix timestamp when the quote was created. */
    createdAt;
    /** The unix timestamp when the service was last updated. */
    updatedAt;
    /** Whether the service worker authority needs to approve new services to use the worker. */
    permissionsRequired;
    /** The available amount of memory on the machine. Trusted to be set correctly by the service worker authority. */
    availableEnclaveSize;
    /** The maximum amount of RAM available to run Trusted Execution Environments (TEEs). */
    maxEnclaveSize;
    /** The maximum CPU that can be given to a service. */
    maxCpu;
    /** The cost to use this service worker. Should this be cost per epoch? */
    enclaveCost;
    /**
     * The SwitchboardWallet account containing the reward escrow for verifying quotes on-chain.
     * We should set this whenever the operator changes so we dont need to pass another account and can verify with has_one.
     */
    rewardEscrow;
    /** The addresses of the services who are being executed by the service worker. */
    services;
    /** The length of valid services for the service worker. */
    servicesLen;
    /** The maximum number of services allowed to run the service. */
    maxServicesLen;
    /** Reserved. */
    ebuf;
    static discriminator = Buffer.from([
        108, 252, 169, 54, 15, 7, 124, 11,
    ]);
    static layout = borsh.struct([
        borsh.u8("status"),
        types.ServerRegion.layout("region"),
        types.ServerZone.layout("zone"),
        borsh.publicKey("authority"),
        borsh.publicKey("attestationQueue"),
        borsh.i64("createdAt"),
        borsh.i64("updatedAt"),
        types.BoolWithLock.layout("permissionsRequired"),
        borsh.u64("availableEnclaveSize"),
        borsh.u64("maxEnclaveSize"),
        borsh.u64("maxCpu"),
        borsh.u64("enclaveCost"),
        borsh.publicKey("rewardEscrow"),
        borsh.array(types.ServiceRow.layout(), 128, "services"),
        borsh.u32("servicesLen"),
        borsh.u32("maxServicesLen"),
        borsh.array(borsh.u8(), 1024, "ebuf"),
    ]);
    constructor(fields) {
        this.status = fields.status;
        this.region = fields.region;
        this.zone = fields.zone;
        this.authority = fields.authority;
        this.attestationQueue = fields.attestationQueue;
        this.createdAt = fields.createdAt;
        this.updatedAt = fields.updatedAt;
        this.permissionsRequired = fields.permissionsRequired;
        this.availableEnclaveSize = fields.availableEnclaveSize;
        this.maxEnclaveSize = fields.maxEnclaveSize;
        this.maxCpu = fields.maxCpu;
        this.enclaveCost = fields.enclaveCost;
        this.rewardEscrow = fields.rewardEscrow;
        this.services = fields.services.map((item) => new types.ServiceRow({ ...item }));
        this.servicesLen = fields.servicesLen;
        this.maxServicesLen = fields.maxServicesLen;
        this.ebuf = fields.ebuf;
    }
    static async fetch(program, address, programId = program.attestationProgramId) {
        const info = await program.connection.getAccountInfo(address);
        if (info === null) {
            return null;
        }
        if (!info.owner.equals(programId)) {
            throw new Error("account doesn't belong to this program");
        }
        return this.decode(info.data);
    }
    static async fetchMultiple(program, addresses, programId = program.attestationProgramId) {
        const infos = await program.connection.getMultipleAccountsInfo(addresses);
        return infos.map((info) => {
            if (info === null) {
                return null;
            }
            if (!info.owner.equals(programId)) {
                throw new Error("account doesn't belong to this program");
            }
            return this.decode(info.data);
        });
    }
    static decode(data) {
        if (!data.slice(0, 8).equals(ServiceWorkerAccountData.discriminator)) {
            throw new Error("invalid account discriminator");
        }
        const dec = ServiceWorkerAccountData.layout.decode(data.slice(8));
        return new ServiceWorkerAccountData({
            status: dec.status,
            region: types.ServerRegion.fromDecoded(dec.region),
            zone: types.ServerZone.fromDecoded(dec.zone),
            authority: dec.authority,
            attestationQueue: dec.attestationQueue,
            createdAt: dec.createdAt,
            updatedAt: dec.updatedAt,
            permissionsRequired: types.BoolWithLock.fromDecoded(dec.permissionsRequired),
            availableEnclaveSize: dec.availableEnclaveSize,
            maxEnclaveSize: dec.maxEnclaveSize,
            maxCpu: dec.maxCpu,
            enclaveCost: dec.enclaveCost,
            rewardEscrow: dec.rewardEscrow,
            services: dec.services.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.ServiceRow.fromDecoded(item)),
            servicesLen: dec.servicesLen,
            maxServicesLen: dec.maxServicesLen,
            ebuf: dec.ebuf,
        });
    }
    toJSON() {
        return {
            status: this.status,
            region: this.region.toJSON(),
            zone: this.zone.toJSON(),
            authority: this.authority.toString(),
            attestationQueue: this.attestationQueue.toString(),
            createdAt: this.createdAt.toString(),
            updatedAt: this.updatedAt.toString(),
            permissionsRequired: this.permissionsRequired.toJSON(),
            availableEnclaveSize: this.availableEnclaveSize.toString(),
            maxEnclaveSize: this.maxEnclaveSize.toString(),
            maxCpu: this.maxCpu.toString(),
            enclaveCost: this.enclaveCost.toString(),
            rewardEscrow: this.rewardEscrow.toString(),
            services: this.services.map((item) => item.toJSON()),
            servicesLen: this.servicesLen,
            maxServicesLen: this.maxServicesLen,
            ebuf: this.ebuf,
        };
    }
    static fromJSON(obj) {
        return new ServiceWorkerAccountData({
            status: obj.status,
            region: types.ServerRegion.fromJSON(obj.region),
            zone: types.ServerZone.fromJSON(obj.zone),
            authority: new PublicKey(obj.authority),
            attestationQueue: new PublicKey(obj.attestationQueue),
            createdAt: new BN(obj.createdAt),
            updatedAt: new BN(obj.updatedAt),
            permissionsRequired: types.BoolWithLock.fromJSON(obj.permissionsRequired),
            availableEnclaveSize: new BN(obj.availableEnclaveSize),
            maxEnclaveSize: new BN(obj.maxEnclaveSize),
            maxCpu: new BN(obj.maxCpu),
            enclaveCost: new BN(obj.enclaveCost),
            rewardEscrow: new PublicKey(obj.rewardEscrow),
            services: obj.services.map((item) => types.ServiceRow.fromJSON(item)),
            servicesLen: obj.servicesLen,
            maxServicesLen: obj.maxServicesLen,
            ebuf: obj.ebuf,
        });
    }
}
